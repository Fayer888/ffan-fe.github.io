{"version":3,"sources":["webpack:///table.min.js","webpack:///./client/app/components/table/table.js","webpack:///./client/app/components/table/table.component.js","webpack:///./client/app/components/table/table.html","webpack:///./client/app/components/table/table.controller.js","webpack:///./client/app/components/table/table.less?3207","webpack:///./client/app/components/table/table.less","webpack:///./~/ffan-ng-table/dist/ng-table.js"],"names":["webpackJsonp","391","module","exports","__webpack_require__","_interopRequireDefault","obj","__esModule","default","Object","defineProperty","value","_table","_table2","_ffanNgTable","_ffanNgTable2","angular","name","component","392","_table3","_table4","restrict","bindings","template","controller","controllerAs","393","394","_classCallCheck","instance","Constructor","TypeError","_createClass","defineProperties","target","props","i","length","descriptor","enumerable","configurable","writable","key","protoProps","staticProps","prototype","TableController","NgTableParams","this","data","total","datas","viewName","lastStatus","lastNO","lastFailNO","init","$inject","getDataList","self","tableParams","page","count","counts","getData","params","395","content","id","locals","396","push","397","__WEBPACK_AMD_DEFINE_ARRAY__","__WEBPACK_AMD_DEFINE_RESULT__","factory","apply","undefined","window","settings","ngTableEventsChannel","$rootScope","addChangeEvent","eventName","fnName","charAt","toUpperCase","substring","event","createEventSubscriptionFn","createPublishEventFn","extend","handler","eventSelector","identity","scope","arguments","isFunction","$new","isObject","requiredPublisher","publisher","$on","isNullInstance","eventArgs","rest","fnArgs","concat","Array","slice","call","$broadcast","array","n","events","ngTableFilterConfigProvider","resetConfigs","config","defaultConfig","setConfig","customConfig","mergeConfig","aliasUrls","ngTableFilterConfig","getTemplateUrl","filterValue","filterKey","indexOf","service","getUrlForAlias","aliasName","defaultBaseUrl","defaultExt","publicConfig","get","copy","$get","provider","ngTableDefaultGetDataProvider","ngTableDefaultGetData","$filter","getFilterFn","filterOptions","filterFn","filterFilterName","getOrderByFn","sortingFilterName","applyFilter","hasFilter","filter","filterKeys","keys","parsedFilter","reduce","result","setPath","filterComparator","applyPaging","pagedData","applySort","orderBy","orderByFn","options","defaultDataOptions","dataOptions","fData","orderedData","path","split","ret","lastKey","parentPathKeys","forEach","hasOwnProperty","ngTableGetDataBcShim","$q","createWrapper","getDataFn","$defer","defer","pData","promise","buildColumn","column","defaultScope","columns","extendedCol","create","defaults","createDefaults","prop","prop1","getterSetter","isScopeLike","assign","$scope","getterFn","context","$column","$columns","class","createGetterSetter","groupable","filterData","noop","headerTemplateURL","headerTitle","sortable","show","title","titleAlt","initialValue","newValue","object","$log","ngTableDefaults","isNumber","isNaN","parseFloat","isFinite","baseParameters","baseSettings","parseGroup","group","defaultSort","groupOptions","sortDirection","isString","grp","convertSortToOrderBy","sorting","createComparableParams","groupSortDirection","hasGlobalSearchFieldChanges","currentVal","$","previousVal","prevParamsMemento","equals","optimizeFilterDelay","filterDelay","defaultFilterOptions","filterDelayThreshold","defaultSettingsFns","runGetData","getDataFnAdaptor","when","runGetGroups","getGroupsFn","getGroupsFnAdaptor","getGroups","runInterceptorPipeline","fetchFn","interceptors","interceptor","thenFn","response","bind","rejectFn","responseError","reject","then","reason","getDefaultSettingFns","dataset","groupFn","groupField","item","getPath","originalDataOptions","adaptedFn","gotData","groups","groupName","$hideRows","isExpanded","finally","ks","errParamsMemento","isCommittedDataset","initialEvents","log","debugMode","debug","filterLayout","defaultGroupOptions","parameters","newParameters","parseParamsFromUrl","isDefined","reverse","len","v","newSettings","isArray","originalDataset","hasDatasetChanged","fireEvent","publishDatasetChanged","significantFilter","groupArray","sortArray","isSortBy","field","direction","generatePagesArray","currentPage","totalItems","pageSize","maxBlocks","maxPage","maxPivotPages","minPage","numPages","pages","Math","ceil","type","number","max","active","current","round","paginationMaxBlocks","paginationMinBlocks","min","isDataReloadRequired","hasGroup","hasFilterChanges","previousFilter","url","asString","collectValue","pairs","encodeURIComponent","isSignificantValue","subkey","pname","reload","$loading","oldData","publishAfterReloadData","reloadPages","$emit","catch","hasErrorState","currentPages","oldPages","newPages","publishPagesChanged","sortingIndicator","publishAfterCreated","$timeout","$parse","$compile","$attrs","$element","ngTableColumn","onDataReloadStatusChange","newStatus","currentParams","delayFilter","setupFilterRowBindingsToInternalScope","showFilter","$parent","$watch","show_filter","hasVisibleFilterColumn","disableFilter","$filterRow","disabled","setupGroupRowBindingsToInternalScope","$groupRow","showGroup","showGroupGetter","getVisibleColumns","c","some","predicate","found","commonInit","bindDataToScope","newDatapage","visibleColumns","$groups","visibleColumnCount","$data","bindPagesToScope","isMyPublisher","onAfterReloadData","onPagesChanged","timer","callback","ms","cancel","newParams","oldParams","compileDirectiveTemplates","hasClass","templates","header","templateHeader","pagination","templatePagination","addClass","headerTemplate","theadFound","children","e","tagName","element","document","createElement","attr","prepend","paginationTemplate","ng-table-pagination","template-url","after","loadFilterData","buildColumns","col","parseNgTableDynamicExpr","parts","Error","setupBindingsToInternalScope","tableParamsExpr","tableParamsGetter","isUndefined","paramsModel","directive","priority","compile","dataRow","groupRow","rows","find","tr","el","getAttrValue","setAttrValue","parsedAttribute","expr","localValue","getter","parsedExpr","titleExpr","attrs","ngTable","tElement","row","showExpr","ngTableDynamic","$watchCollection","newCols","ngTableColumnsBinding","linkFn","setter","newColumns","shallowClone","require","link","templateUrl","replace","pubParams","ng-include","append","ngTableFilterRowController","getFilterCellCss","layout","size","width","parseInt","getFilterPlaceholderValue","placeholder","ngTableFilterRow","ngTableGroupRowController","getGroupables","getGroupTitle","groupBy","isSelectedGroup","toggleDetail","setGroup","changeSortDirection","newDirection","$selGroup","findGroupColumn","groupKey","groupableCols","groupFns","existingGroupCol","$selGroupTitle","groupedColumn","ngTableGroupRow","ngTableSorterRowController","sortBy","parsedSortable","inverseSort","sortingParams","ctrlKey","metaKey","ngTableSorterRow","ngTableSelectFilterDs","ngTableSelectFilterDsController","bindDataSource","getSelectListData","hasEmptyOption","unshift","$selectData","isMatch","run","$templateCache","put"],"mappings":"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","file":"table.min.js","sourcesContent":["webpackJsonp([4],{\n\n/***/ 391:\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\tObject.defineProperty(exports, \"__esModule\", {\n\t\t\tvalue: true\n\t});\n\t\n\tvar _table = __webpack_require__(392);\n\t\n\tvar _table2 = _interopRequireDefault(_table);\n\t\n\tvar _ffanNgTable = __webpack_require__(397);\n\t\n\tvar _ffanNgTable2 = _interopRequireDefault(_ffanNgTable);\n\t\n\tfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\t\n\texports.default = angular.module('tableDemo', [_ffanNgTable2.default.name])\n\t/**\n\t * 轻在routerConfig.js里定义路由\n\t */\n\t.component('tableDemo', _table2.default);\n\n/***/ },\n\n/***/ 392:\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\tObject.defineProperty(exports, \"__esModule\", {\n\t  value: true\n\t});\n\t\n\tvar _table = __webpack_require__(393);\n\t\n\tvar _table2 = _interopRequireDefault(_table);\n\t\n\tvar _table3 = __webpack_require__(394);\n\t\n\tvar _table4 = _interopRequireDefault(_table3);\n\t\n\t__webpack_require__(395);\n\t\n\tfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\t\n\texports.default = {\n\t  restrict: 'E',\n\t  bindings: {},\n\t  template: _table2.default,\n\t  controller: _table4.default,\n\t  controllerAs: 'vm'\n\t};\n\n/***/ },\n\n/***/ 393:\n/***/ function(module, exports) {\n\n\tmodule.exports = \"<section class=\\\"intro-content\\\">\\n\\t<h1>表格</h1>\\n\\t<p>用于展示多条结构类似的数据，可对数据进行排序、筛选、对比或其他自定义操作。</p>\\n\\t<h2>安装</h2>\\n\\t<p>安装 ffan-ng-table</p>\\n</section>\\n\\n<div class=\\\"example-block\\\">\\n\\t<div class=\\\"highlight no-border\\\" hljs hljs-language=\\\"bash\\\">npm install ffan-ng-table --save</div>\\n</div>\\n\\n<section class=\\\"intro-content\\\">\\n\\t<h2>注入模块</h2>\\n\\t<p>在app.js或使用表格的模板入口js中注入 ffan-ng-table</p>\\n</section>\\n\\n<div class=\\\"example-block\\\">\\n<div class=\\\"highlight no-border\\\" hljs hljs-language=\\\"javascript\\\">\\nimport ffanTable from 'ffan-ng-table';\\n\\nangular.module('app', [\\n  ffanTable.name\\n])\\n.constant('$menuConstant', {\\n  DEBUG: process.env.DEBUG\\n})\\n.component('app', AppComponent);\\n</div>\\n</div>\\n\\n<section class=\\\"intro-content\\\">\\n\\t<h2>示例</h2>\\n</section>\\n\\n<div class=\\\"table-container\\\">\\n\\t<div class=\\\"table-wrapper ng-scope ng-table\\\">\\n\\t\\t<table class=\\\"table table-bordered table-hover\\\" ng-table=\\\"vm.tableParams\\\">\\n\\t\\t\\t<thead>\\n\\t\\t\\t<tr>\\n\\t\\t\\t\\t<th style=\\\"width: 25%;\\\">名称</th>\\n\\t\\t\\t\\t<th style=\\\"width: 15%;\\\">视图名称</th>\\n\\t\\t\\t\\t<th style=\\\"width: 20%;\\\">上一次编译结果的状态</th>\\n\\t\\t\\t\\t<th style=\\\"width: 20%;\\\">上一次编译结果的序号</th>\\n\\t\\t\\t\\t<th style=\\\"width: 20%;\\\">上一次编译失败的序号</th>\\n\\t\\t\\t</tr>\\n\\t\\t\\t</thead>\\n\\t\\t\\t<tbody ng-if=\\\"vm.tableParams.data.length != 0\\\">\\n\\t\\t\\t<tr ng-repeat=\\\"row in $data\\\">\\n\\t\\t\\t\\t<td>{{row.name}}</td>\\n\\t\\t\\t\\t<td>{{row.viewName}}</td>\\n\\t\\t\\t\\t<td>{{row.lastStatus}}</td>\\n\\t\\t\\t\\t<td>{{row.lastNO}}</td>\\n\\t\\t\\t\\t<td>{{row.lastFailNO}}</td>\\n\\t\\t\\t</tr>\\n\\t\\t\\t</tbody>\\n\\t\\t</table>\\n\\n\\t\\t<div class=\\\"prompt\\\" ng-if=\\\"vm.tableParams.data.length != 0\\\">\\n\\t\\t\\t<p class=\\\"text-danger\\\">点击存储卷名称可对其进行文件导入，导出操作.</p>\\n\\t\\t</div>\\n\\t\\t<div class=\\\"no-result\\\" ng-if=\\\"vm.tableParams.data.length == 0\\\">结果为空</div>\\n\\t</div>\\n</div>\\n\\n<div class=\\\"example-block\\\"  style=\\\"margin-top: 30px\\\">\\n\\t<div class=\\\"bs-example\\\">\\n\\t\\tview代码\\n\\t</div>\\n<div class=\\\"highlight\\\" hljs hljs-language=\\\"html\\\">\\n<div class=\\\"table-container\\\">\\n  <div class=\\\"table-wrapper ng-scope ng-table\\\">\\n\\t<table class=\\\"table table-bordered table-hover\\\" ng-table=\\\"vm.tableParams\\\">\\n\\t  <thead>\\n\\t\\t<tr>\\n\\t\\t  <th style=\\\"width: 25%;\\\">名称</th>\\n\\t\\t  <th style=\\\"width: 15%;\\\">视图名称</th>\\n\\t\\t  <th style=\\\"width: 20%;\\\">上一次编译结果的状态</th>\\n\\t\\t  <th style=\\\"width: 20%;\\\">上一次编译结果的序号</th>\\n\\t\\t  <th style=\\\"width: 20%;\\\">上一次编译失败的序号</th>\\n\\t\\t</tr>\\n\\t  </thead>\\n\\t  <tbody ng-if=\\\"vm.tableParams.data.length != 0\\\">\\n\\t    <tr ng-repeat=\\\"row in $data\\\">\\n\\t\\t  <td>{{row.name}}</td>\\n\\t\\t  <td>{{row.viewName}}</td>\\n\\t\\t  <td>{{row.lastStatus}}</td>\\n\\t\\t  <td>{{row.lastNO}}</td>\\n\\t\\t  <td>{{row.lastFailNO}}</td>\\n\\t    </tr>\\n\\t  </tbody>\\n\\t</table>\\n\\t<div class=\\\"prompt\\\" ng-if=\\\"vm.tableParams.data.length != 0\\\">\\n\\t  <p class=\\\"text-warning\\\">点击存储卷名称可对其进行文件导入，导出操作.</p>\\n\\t</div>\\n\\t<div class=\\\"no-result\\\" ng-if=\\\"vm.tableParams.data.length == 0\\\">结果为空</div>\\n  </div>\\n</div>\\n</div>\\n</div>\\n\\n\\n<div class=\\\"example-block\\\" style=\\\"margin-top: 30px\\\">\\n\\t<div class=\\\"bs-example\\\">\\n\\t\\tcontroller代码\\n\\t</div>\\n<div class=\\\"highlight\\\" hljs hljs-language=\\\"javascript\\\">\\nconstructor(NgTableParams) {\\n  \\\"ngInject\\\";\\n  this.NgTableParams = NgTableParams;\\n  this.init();\\n}\\n\\ninit(){\\n  var self = this;\\n    self.tableParams = new this.NgTableParams({\\n      page: 1,\\n      count: 5\\n    }, {\\n    counts: [],\\n      getData: function (params) {\\n      // call service to get table data\\n      params.total(self.data.total);\\n      return self.data && self.data.datas;\\n    }\\n  });\\n}\\n</div>\\n</div>\"\n\n/***/ },\n\n/***/ 394:\n/***/ function(module, exports) {\n\n\t\"use strict\";\n\t\n\tObject.defineProperty(exports, \"__esModule\", {\n\t\tvalue: true\n\t});\n\t\n\tvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\t\n\tfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\t\n\t/**\n\t * (description)\n\t *\n\t * @author yourname\n\t */\n\t\n\tvar TableController = function () {\n\t\tTableController.$inject = [\"NgTableParams\"];\n\t\tfunction TableController(NgTableParams) {\n\t\t\t\"ngInject\";\n\t\n\t\t\t_classCallCheck(this, TableController);\n\t\n\t\t\tthis.NgTableParams = NgTableParams;\n\t\t\tthis.data = {\n\t\t\t\t\"total\": 85,\n\t\t\t\t\"datas\": [{\n\t\t\t\t\t\"name\": 'fix_web',\n\t\t\t\t\t\"viewName\": \"tool-wd\",\n\t\t\t\t\t\"lastStatus\": \"SUCCESS\",\n\t\t\t\t\t\"lastNO\": \"#10\",\n\t\t\t\t\t\"lastFailNO\": \"#4\"\n\t\t\t\t}, {\n\t\t\t\t\t\"name\": 'fix_web',\n\t\t\t\t\t\"viewName\": \"tool-wd\",\n\t\t\t\t\t\"lastStatus\": \"SUCCESS\",\n\t\t\t\t\t\"lastNO\": \"#10\",\n\t\t\t\t\t\"lastFailNO\": \"#4\"\n\t\t\t\t}, {\n\t\t\t\t\t\"name\": 'fix_web',\n\t\t\t\t\t\"viewName\": \"tool-wd\",\n\t\t\t\t\t\"lastStatus\": \"SUCCESS\",\n\t\t\t\t\t\"lastNO\": \"#10\",\n\t\t\t\t\t\"lastFailNO\": \"#4\"\n\t\t\t\t}, {\n\t\t\t\t\t\"name\": 'fix_web',\n\t\t\t\t\t\"viewName\": \"tool-wd\",\n\t\t\t\t\t\"lastStatus\": \"SUCCESS\",\n\t\t\t\t\t\"lastNO\": \"#10\",\n\t\t\t\t\t\"lastFailNO\": \"#4\"\n\t\t\t\t}, {\n\t\t\t\t\t\"name\": 'fix_web',\n\t\t\t\t\t\"viewName\": \"tool-wd\",\n\t\t\t\t\t\"lastStatus\": \"SUCCESS\",\n\t\t\t\t\t\"lastNO\": \"#10\",\n\t\t\t\t\t\"lastFailNO\": \"#4\"\n\t\t\t\t}]\n\t\t\t};\n\t\t\tthis.init();\n\t\t}\n\t\n\t\t_createClass(TableController, [{\n\t\t\tkey: \"init\",\n\t\t\tvalue: function init() {\n\t\t\t\tthis.getDataList();\n\t\t\t}\n\t\t}, {\n\t\t\tkey: \"getDataList\",\n\t\t\tvalue: function getDataList() {\n\t\t\t\tvar self = this;\n\t\t\t\tself.tableParams = new this.NgTableParams({\n\t\t\t\t\tpage: 1,\n\t\t\t\t\tcount: 5\n\t\t\t\t}, {\n\t\t\t\t\tcounts: [],\n\t\t\t\t\tgetData: function getData(params) {\n\t\t\t\t\t\t// call service to get table data\n\t\t\t\t\t\tparams.total(self.data.total);\n\t\t\t\t\t\treturn self.data && self.data.datas;\n\t\t\t\t\t}\n\t\t\t\t});\n\t\t\t}\n\t\t}]);\n\t\n\t\treturn TableController;\n\t}();\n\t\n\texports.default = TableController;\n\n/***/ },\n\n/***/ 395:\n/***/ function(module, exports, __webpack_require__) {\n\n\t// style-loader: Adds some css to the DOM by adding a <style> tag\n\t\n\t// load the styles\n\tvar content = __webpack_require__(396);\n\tif(typeof content === 'string') content = [[module.id, content, '']];\n\t// add the styles to the DOM\n\tvar update = __webpack_require__(100)(content, {});\n\tif(content.locals) module.exports = content.locals;\n\t// Hot Module Replacement\n\tif(false) {\n\t\t// When the styles change, update the <style> tags\n\t\tif(!content.locals) {\n\t\t\tmodule.hot.accept(\"!!./../../../../node_modules/css-loader/index.js!./../../../../node_modules/less-loader/index.js!./table.less\", function() {\n\t\t\t\tvar newContent = require(\"!!./../../../../node_modules/css-loader/index.js!./../../../../node_modules/less-loader/index.js!./table.less\");\n\t\t\t\tif(typeof newContent === 'string') newContent = [[module.id, newContent, '']];\n\t\t\t\tupdate(newContent);\n\t\t\t});\n\t\t}\n\t\t// When the module is disposed, remove the <style> tags\n\t\tmodule.hot.dispose(function() { update(); });\n\t}\n\n/***/ },\n\n/***/ 396:\n/***/ function(module, exports, __webpack_require__) {\n\n\texports = module.exports = __webpack_require__(94)();\n\t// imports\n\t\n\t\n\t// module\n\texports.push([module.id, \"\", \"\"]);\n\t\n\t// exports\n\n\n/***/ },\n\n/***/ 397:\n/***/ function(module, exports, __webpack_require__) {\n\n\tvar __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;(function(angular, factory) {\n\t    'use strict';\n\t\n\t    if (true) {\n\t        !(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(87)], __WEBPACK_AMD_DEFINE_RESULT__ = function(angular) {\n\t            return factory(angular);\n\t        }.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n\t    } else {\n\t        return factory(angular);\n\t    }\n\t}(window.angular || null, function(angular) {\n\t    'use strict';\n\t\n\t/**\n\t * ngTable: Table + Angular JS\n\t *\n\t * @author Vitalii Savchuk <esvit666@gmail.com>\n\t * @url https://github.com/esvit/ng-table/\n\t * @license New BSD License <http://creativecommons.org/licenses/BSD/>\n\t */\n\t\n\t(function(){\n\t    /**\n\t     * @ngdoc module\n\t     * @name ngTable\n\t     * @description ngTable: Table + Angular JS\n\t     */\n\t    angular.module('ngTable', []);\n\t})();\n\t\n\t/**\n\t * ngTable: Table + Angular JS\n\t *\n\t * @author Vitalii Savchuk <esvit666@gmail.com>\n\t * @url https://github.com/esvit/ng-table/\n\t * @license New BSD License <http://creativecommons.org/licenses/BSD/>\n\t */\n\t\n\t(function () {\n\t    /**\n\t     * @ngdoc object\n\t     * @name ngTableDefaultParams\n\t     * @module ngTable\n\t     * @description Default Parameters for ngTable\n\t     */\n\t    angular.module('ngTable')\n\t        .value('ngTableDefaults', {\n\t            params: {},\n\t            settings: {}\n\t        });\n\t})();\n\t\n\t/**\n\t * ngTable: Table + Angular JS\n\t *\n\t * @author Vitalii Savchuk <esvit666@gmail.com>\n\t * @url https://github.com/esvit/ng-table/\n\t * @license New BSD License <http://creativecommons.org/licenses/BSD/>\n\t */\n\t\n\t(function(){\n\t    'use strict';\n\t\n\t    angular.module('ngTable')\n\t        .factory('ngTableEventsChannel', ngTableEventsChannel);\n\t\n\t    ngTableEventsChannel.$inject = ['$rootScope'];\n\t\n\t    /**\n\t     * @ngdoc service\n\t     * @name ngTableEventsChannel\n\t     * @description strongly typed pub/sub for `NgTableParams`\n\t     *\n\t     * Supported events:\n\t     *\n\t     * * afterCreated - raised when a new instance of `NgTableParams` has finished being constructed\n\t     * * afterReloadData - raised when the `reload` event has finished loading new data\n\t     * * datasetChanged - raised when `settings` receives a new data array\n\t     * * pagesChanged - raised when a new pages array has been generated\n\t     */\n\t    function ngTableEventsChannel($rootScope){\n\t\n\t        var events = {};\n\t        events = addChangeEvent('afterCreated', events);\n\t        events = addChangeEvent('afterReloadData', events);\n\t        events = addChangeEvent('datasetChanged', events);\n\t        events = addChangeEvent('pagesChanged', events);\n\t        return events;\n\t\n\t        //////////\n\t\n\t        function addChangeEvent(eventName, target){\n\t            var fnName = eventName.charAt(0).toUpperCase() + eventName.substring(1);\n\t            var event = {};\n\t            event['on' + fnName] = createEventSubscriptionFn(eventName);\n\t            event['publish' + fnName] = createPublishEventFn(eventName);\n\t            return angular.extend(target, event);\n\t        }\n\t\n\t        function createEventSubscriptionFn(eventName){\n\t\n\t            return function subscription(handler/*[, eventSelector or $scope][, eventSelector]*/){\n\t                var eventSelector = angular.identity;\n\t                var scope = $rootScope;\n\t\n\t                if (arguments.length === 2){\n\t                    if (angular.isFunction(arguments[1].$new)) {\n\t                        scope = arguments[1];\n\t                    } else {\n\t                        eventSelector = arguments[1]\n\t                    }\n\t                } else if (arguments.length > 2){\n\t                    scope = arguments[1];\n\t                    eventSelector = arguments[2];\n\t                }\n\t\n\t                // shorthand for subscriber to only receive events from a specific publisher instance\n\t                if (angular.isObject(eventSelector)) {\n\t                    var requiredPublisher = eventSelector;\n\t                    eventSelector = function(publisher){\n\t                        return publisher === requiredPublisher;\n\t                    }\n\t                }\n\t\n\t                return scope.$on('ngTable:' + eventName, function(event, params/*, ...args*/){\n\t                    // don't send events published by the internal NgTableParams created by ngTableController\n\t                    if (params.isNullInstance) return;\n\t\n\t                    var eventArgs = rest(arguments, 2);\n\t                    var fnArgs = [params].concat(eventArgs);\n\t                    if (eventSelector.apply(this, fnArgs)){\n\t                        handler.apply(this, fnArgs);\n\t                    }\n\t                });\n\t            }\n\t        }\n\t\n\t        function createPublishEventFn(eventName){\n\t            return function publish(/*args*/){\n\t                var fnArgs = ['ngTable:' + eventName].concat(Array.prototype.slice.call(arguments));\n\t                $rootScope.$broadcast.apply($rootScope, fnArgs);\n\t            }\n\t        }\n\t\n\t        function rest(array, n) {\n\t            return Array.prototype.slice.call(array, n == null ? 1 : n);\n\t        }\n\t    }\n\t})();\n\t\n\t/**\n\t * ngTable: Table + Angular JS\n\t *\n\t * @author Vitalii Savchuk <esvit666@gmail.com>\n\t * @url https://github.com/esvit/ng-table/\n\t * @license New BSD License <http://creativecommons.org/licenses/BSD/>\n\t */\n\t\n\t(function(){\n\t    'use strict';\n\t\n\t    angular.module('ngTable')\n\t        .provider('ngTableFilterConfig', ngTableFilterConfigProvider);\n\t\n\t    ngTableFilterConfigProvider.$inject = [];\n\t\n\t    function ngTableFilterConfigProvider(){\n\t        var config;\n\t        var defaultConfig = {\n\t            defaultBaseUrl: 'ng-table/filters/',\n\t            defaultExt: '.html',\n\t            aliasUrls: {}\n\t        };\n\t\n\t        this.$get = ngTableFilterConfig;\n\t        this.resetConfigs = resetConfigs;\n\t        this.setConfig = setConfig;\n\t\n\t        init();\n\t\n\t        /////////\n\t\n\t        function init(){\n\t            resetConfigs();\n\t        }\n\t\n\t        function resetConfigs(){\n\t            config = defaultConfig;\n\t        }\n\t\n\t        function setConfig(customConfig){\n\t            var mergeConfig = angular.extend({}, config, customConfig);\n\t            mergeConfig.aliasUrls = angular.extend({}, config.aliasUrls, customConfig.aliasUrls);\n\t            config = mergeConfig;\n\t        }\n\t\n\t        /////////\n\t\n\t        ngTableFilterConfig.$inject = [];\n\t\n\t        function ngTableFilterConfig(){\n\t\n\t            var publicConfig;\n\t\n\t            var service = {\n\t                config: publicConfig,\n\t                getTemplateUrl: getTemplateUrl,\n\t                getUrlForAlias: getUrlForAlias\n\t            };\n\t            Object.defineProperty(service, \"config\", {\n\t                get: function(){\n\t                    return publicConfig = publicConfig || angular.copy(config);\n\t                },\n\t                enumerable: true\n\t            });\n\t\n\t            return service;\n\t\n\t            /////////\n\t\n\t            function getTemplateUrl(filterValue, filterKey){\n\t                if (angular.isObject(filterValue)){\n\t                    filterValue = filterValue.id;\n\t                }\n\t                if (filterValue.indexOf('/') !== -1){\n\t                    return filterValue;\n\t                }\n\t\n\t                return service.getUrlForAlias(filterValue, filterKey);\n\t            }\n\t\n\t            function getUrlForAlias(aliasName/*, filterKey*/){\n\t                return config.aliasUrls[aliasName] || config.defaultBaseUrl + aliasName + config.defaultExt;\n\t            }\n\t        }\n\t    }\n\t})();\n\t\n\t/**\n\t * ngTable: Table + Angular JS\n\t *\n\t * @author Vitalii Savchuk <esvit666@gmail.com>\n\t * @url https://github.com/esvit/ng-table/\n\t * @license New BSD License <http://creativecommons.org/licenses/BSD/>\n\t */\n\t\n\t(function(){\n\t    'use strict';\n\t\n\t\n\t    angular.module('ngTable')\n\t        .provider('ngTableDefaultGetData', ngTableDefaultGetDataProvider);\n\t\n\t    ngTableDefaultGetDataProvider.$inject = [];\n\t\n\t    /**\n\t     * @ngdoc provider\n\t     * @name ngTableDefaultGetDataProvider\n\t     * @description Allows for the configuration of the ngTableDefaultGetData service.\n\t     *\n\t     * Set filterFilterName to the name of a angular filter that knows how to apply the values returned by\n\t     * `NgTableParams.filter()` to restrict an array of data.\n\t     *\n\t     * Set sortingFilterName to the name of a angular filter that knows how to apply the values returned by\n\t     * `NgTableParams.orderBy()` to sort an array of data.\n\t     *\n\t     * Out of the box the `ngTableDefaultGetData` service will be configured to use the angular `filter` and `orderBy`\n\t     * filters respectively\n\t     */\n\t    function ngTableDefaultGetDataProvider(){\n\t        var provider = this;\n\t        provider.$get = ngTableDefaultGetData;\n\t        provider.filterFilterName = 'filter';\n\t        provider.sortingFilterName = 'orderBy';\n\t\n\t        ///////////\n\t\n\t        ngTableDefaultGetData.$inject = ['$filter'];\n\t\n\t        /**\n\t         * @ngdoc service\n\t         * @name ngTableDefaultGetData\n\t         * @description A default implementation of the getData function that will apply the `filter`, `orderBy` and\n\t         * paging values from the `NgTableParams` instance supplied to the data array supplied.\n\t         *\n\t         * The outcome will be to return the resulting array and to assign the total item count after filtering\n\t         * to the `total` of the `NgTableParams` instance supplied\n\t         */\n\t        function ngTableDefaultGetData($filter) {\n\t\n\t            var defaultDataOptions = {applyFilter: true, applySort: true, applyPaging: true};\n\t\n\t            getData.applyPaging = applyPaging;\n\t            getData.getFilterFn = getFilterFn;\n\t            getData.getOrderByFn = getOrderByFn;\n\t\n\t            return getData;\n\t\n\t            function getFilterFn(params) {\n\t                var filterOptions = params.settings().filterOptions;\n\t                if (angular.isFunction(filterOptions.filterFn)){\n\t                    return filterOptions.filterFn;\n\t                } else {\n\t                    return $filter(filterOptions.filterFilterName || provider.filterFilterName);\n\t                }\n\t            }\n\t\n\t            function getOrderByFn (/*params*/){\n\t                return $filter(provider.sortingFilterName);\n\t            }\n\t\n\t            function applyFilter(data, params) {\n\t                if (!params.hasFilter()) {\n\t                    return data;\n\t                }\n\t\n\t                var filter = params.filter(true);\n\t                var filterKeys = Object.keys(filter);\n\t                var parsedFilter = filterKeys.reduce(function(result, key){\n\t                    result = setPath(result, filter[key], key);\n\t                    return result;\n\t                }, {});\n\t                var filterFn = getFilterFn(params);\n\t                return filterFn.call(params, data, parsedFilter, params.settings().filterOptions.filterComparator);\n\t            }\n\t\n\t            function applyPaging(data, params) {\n\t                var pagedData = data.slice((params.page() - 1) * params.count(), params.page() * params.count());\n\t                params.total(data.length); // set total for recalc pagination\n\t                return pagedData;\n\t            }\n\t\n\t            function applySort(data, params) {\n\t                var orderBy = params.orderBy();\n\t                var orderByFn = getOrderByFn(params);\n\t                return orderBy.length ? orderByFn(data, orderBy) : data;\n\t            }\n\t\n\t            function getData(data, params) {\n\t                if (data == null){\n\t                    return [];\n\t                }\n\t\n\t                var options = angular.extend({}, defaultDataOptions, params.settings().dataOptions);\n\t\n\t                var fData = options.applyFilter ? applyFilter(data, params) : data;\n\t                var orderedData = options.applySort ? applySort(fData, params) : fData;\n\t                return options.applyPaging ? applyPaging(orderedData, params) : orderedData;\n\t            }\n\t\n\t            // Sets the value at any depth in a nested object based on the path\n\t            // note: adapted from: underscore-contrib#setPath\n\t            function setPath(obj, value, path) {\n\t                var keys     = path.split('.');\n\t                var ret      = obj;\n\t                var lastKey  = keys[keys.length -1];\n\t                var target   = ret;\n\t\n\t                var parentPathKeys = keys.slice(0, keys.length -1);\n\t                parentPathKeys.forEach(function(key) {\n\t                    if (!target.hasOwnProperty(key)) {\n\t                        target[key] = {};\n\t                    }\n\t                    target = target[key];\n\t                });\n\t\n\t                target[lastKey] = value;\n\t                return ret;\n\t            }\n\t        }\n\t    }\n\t})();\n\t\n\t/**\n\t * ngTable: Table + Angular JS\n\t *\n\t * @author Vitalii Savchuk <esvit666@gmail.com>\n\t * @url https://github.com/esvit/ng-table/\n\t * @license New BSD License <http://creativecommons.org/licenses/BSD/>\n\t */\n\t\n\t(function(){\n\t    'use strict';\n\t\n\t    // todo: remove shim after an acceptable depreciation period\n\t\n\t    angular.module('ngTable')\n\t        .factory('ngTableGetDataBcShim', ngTableGetDataBcShim);\n\t\n\t    ngTableGetDataBcShim.$inject = ['$q'];\n\t\n\t    function ngTableGetDataBcShim($q){\n\t\n\t        return createWrapper;\n\t\n\t        function createWrapper(getDataFn){\n\t            return function getDataShim(/*args*/){\n\t                var $defer = $q.defer();\n\t                var pData = getDataFn.apply(this, [$defer].concat(Array.prototype.slice.call(arguments)));\n\t                if (!pData) {\n\t                    // If getData resolved the $defer, and didn't promise us data,\n\t                    //   create a promise from the $defer. We need to return a promise.\n\t                    pData = $defer.promise;\n\t                }\n\t                return pData;\n\t            }\n\t        }\n\t    }\n\t})();\n\t\n\t/**\n\t * ngTable: Table + Angular JS\n\t *\n\t * @author Vitalii Savchuk <esvit666@gmail.com>\n\t * @url https://github.com/esvit/ng-table/\n\t * @license New BSD License <http://creativecommons.org/licenses/BSD/>\n\t */\n\t\n\t(function () {\n\t    /**\n\t     * @ngdoc service\n\t     * @name ngTableColumn\n\t     * @module ngTable\n\t     * @description\n\t     * Service to construct a $column definition used by {@link ngTable ngTable} directive\n\t     */\n\t    angular.module('ngTable').factory('ngTableColumn', [function () {\n\t\n\t        return {\n\t            buildColumn: buildColumn\n\t        };\n\t\n\t        //////////////\n\t\n\t        /**\n\t         * @ngdoc method\n\t         * @name ngTableColumn#buildColumn\n\t         * @description Creates a $column for use within a header template\n\t         *\n\t         * @param {Object} column an existing $column or simple column data object\n\t         * @param {Scope} defaultScope the $scope to supply to the $column getter methods when not supplied by caller\n\t         * @param {Array} columns a reference to the columns array to make available on the context supplied to the\n\t         * $column getter methods\n\t         * @returns {Object} a $column object\n\t         */\n\t        function buildColumn(column, defaultScope, columns){\n\t            // note: we're not modifying the original column object. This helps to avoid unintended side affects\n\t            var extendedCol = Object.create(column);\n\t            var defaults = createDefaults();\n\t            for (var prop in defaults) {\n\t                if (extendedCol[prop] === undefined) {\n\t                    extendedCol[prop] = defaults[prop];\n\t                }\n\t                if(!angular.isFunction(extendedCol[prop])){\n\t                    // wrap raw field values with \"getter\" functions\n\t                    // - this is to ensure consistency with how ngTable.compile builds columns\n\t                    // - note that the original column object is being \"proxied\"; this is important\n\t                    //   as it ensure that any changes to the original object will be returned by the \"getter\"\n\t                    (function(prop1){\n\t                        var getterSetter = function getterSetter(/*[value] || [$scope, locals]*/) {\n\t                            if (arguments.length === 1 && !isScopeLike(arguments[0])) {\n\t                                getterSetter.assign(null, arguments[0]);\n\t                            } else {\n\t                                return column[prop1];\n\t                            }\n\t                        };\n\t                        getterSetter.assign = function($scope, value){\n\t                            column[prop1] = value;\n\t                        };\n\t                        extendedCol[prop1] = getterSetter;\n\t                    })(prop);\n\t                }\n\t                (function(prop1){\n\t                    // satisfy the arguments expected by the function returned by parsedAttribute in the ngTable directive\n\t                    var getterFn = extendedCol[prop1];\n\t                    extendedCol[prop1] = function () {\n\t                        if (arguments.length === 1 && !isScopeLike(arguments[0])){\n\t                            getterFn.assign(null, arguments[0]);\n\t                        } else {\n\t                            var scope = arguments[0] || defaultScope;\n\t                            var context = Object.create(scope);\n\t                            angular.extend(context, {\n\t                                $column: extendedCol,\n\t                                $columns: columns\n\t                            });\n\t                            return getterFn.call(column, context);\n\t                        }\n\t                    };\n\t                    if (getterFn.assign){\n\t                        extendedCol[prop1].assign = getterFn.assign;\n\t                    }\n\t                })(prop);\n\t            }\n\t            return extendedCol;\n\t        }\n\t\n\t        function createDefaults(){\n\t            return {\n\t                'class': createGetterSetter(''),\n\t                filter: createGetterSetter(false),\n\t                groupable: createGetterSetter(false),\n\t                filterData: angular.noop,\n\t                headerTemplateURL: createGetterSetter(false),\n\t                headerTitle: createGetterSetter(''),\n\t                sortable: createGetterSetter(false),\n\t                show: createGetterSetter(true),\n\t                title: createGetterSetter(''),\n\t                titleAlt: createGetterSetter('')\n\t            };\n\t        }\n\t\n\t        function createGetterSetter(initialValue){\n\t            var value = initialValue;\n\t            var getterSetter = function getterSetter(/*[value] || [$scope, locals]*/){\n\t                if (arguments.length === 1 && !isScopeLike(arguments[0])) {\n\t                    getterSetter.assign(null, arguments[0]);\n\t                } else {\n\t                    return value;\n\t                }\n\t            };\n\t            getterSetter.assign = function($scope, newValue){\n\t                value = newValue;\n\t            };\n\t            return getterSetter;\n\t        }\n\t\n\t        function isScopeLike(object){\n\t            return object != null && angular.isFunction(object.$new);\n\t        }\n\t    }]);\n\t})();\n\t\n\t/**\n\t * ngTable: Table + Angular JS\n\t *\n\t * @author Vitalii Savchuk <esvit666@gmail.com>\n\t * @url https://github.com/esvit/ng-table/\n\t * @license New BSD License <http://creativecommons.org/licenses/BSD/>\n\t */\n\t\n\t(function(){\n\t    /**\n\t     * @ngdoc service\n\t     * @name NgTableParams\n\t     * @module ngTable\n\t     * @description Parameters manager for ngTable\n\t     */\n\t\n\t    angular.module('ngTable').factory('NgTableParams', ['$q', '$log', '$filter', 'ngTableDefaults', 'ngTableGetDataBcShim', 'ngTableDefaultGetData', 'ngTableEventsChannel', function($q, $log, $filter, ngTableDefaults, ngTableGetDataBcShim, ngTableDefaultGetData, ngTableEventsChannel) {\n\t        var isNumber = function(n) {\n\t            return !isNaN(parseFloat(n)) && isFinite(n);\n\t        };\n\t        var NgTableParams = function(baseParameters, baseSettings) {\n\t\n\t            // the ngTableController \"needs\" to create a dummy/null instance and it's important to know whether an instance\n\t            // is one of these\n\t            if (typeof baseParameters === \"boolean\"){\n\t                this.isNullInstance = true;\n\t            }\n\t\n\t            var self = this,\n\t                prevParamsMemento,\n\t                errParamsMemento,\n\t                isCommittedDataset = false,\n\t                initialEvents = [],\n\t                log = function() {\n\t                    if (settings.debugMode && $log.debug) {\n\t                        $log.debug.apply($log, arguments);\n\t                    }\n\t                },\n\t                defaultFilterOptions = {\n\t                    filterComparator: undefined, // look for a substring match in case insensitive way\n\t                    filterDelay: 500,\n\t                    filterDelayThreshold: 10000, // size of dataset array that will trigger the filterDelay being applied\n\t                    filterFilterName: undefined, // when defined overrides ngTableDefaultGetDataProvider.filterFilterName\n\t                    filterFn: undefined, // when defined overrides the filter function that ngTableDefaultGetData uses\n\t                    filterLayout: 'stack' // alternative: 'horizontal'\n\t                },\n\t                defaultGroupOptions = {\n\t                    defaultSort: 'asc', // set to 'asc' or 'desc' to apply sorting to groups\n\t                    isExpanded: true\n\t                },\n\t                defaultSettingsFns = getDefaultSettingFns();\n\t\n\t            this.data = [];\n\t\n\t            /**\n\t             * @ngdoc method\n\t             * @name NgTableParams#parameters\n\t             * @description Set new parameters or get current parameters\n\t             *\n\t             * @param {string} newParameters      New parameters\n\t             * @param {string} parseParamsFromUrl Flag if parse parameters like in url\n\t             * @returns {Object} Current parameters or `this`\n\t             */\n\t            this.parameters = function(newParameters, parseParamsFromUrl) {\n\t                parseParamsFromUrl = parseParamsFromUrl || false;\n\t                if (angular.isDefined(newParameters)) {\n\t                    for (var key in newParameters) {\n\t                        var value = newParameters[key];\n\t                        if (parseParamsFromUrl && key.indexOf('[') >= 0) {\n\t                            var keys = key.split(/\\[(.*)\\]/).reverse()\n\t                            var lastKey = '';\n\t                            for (var i = 0, len = keys.length; i < len; i++) {\n\t                                var name = keys[i];\n\t                                if (name !== '') {\n\t                                    var v = value;\n\t                                    value = {};\n\t                                    value[lastKey = name] = (isNumber(v) ? parseFloat(v) : v);\n\t                                }\n\t                            }\n\t                            if (lastKey === 'sorting') {\n\t                                params[lastKey] = {};\n\t                            }\n\t                            params[lastKey] = angular.extend(params[lastKey] || {}, value[lastKey]);\n\t                        } else {\n\t                            if (key === 'group'){\n\t                                params[key] = parseGroup(newParameters[key]);\n\t                            } else {\n\t                                params[key] = (isNumber(newParameters[key]) ? parseFloat(newParameters[key]) : newParameters[key]);\n\t                            }\n\t                        }\n\t                    }\n\t                    log('ngTable: set parameters', params);\n\t                    return this;\n\t                }\n\t                return params;\n\t            };\n\t\n\t            function parseGroup(group){\n\t                var defaultSort = settings.groupOptions && settings.groupOptions.defaultSort;\n\t                if (angular.isFunction(group)) {\n\t                    if (group.sortDirection == null){\n\t                        group.sortDirection = defaultSort;\n\t                    }\n\t                    return group;\n\t                } else if (angular.isString(group)) {\n\t                    var grp = {};\n\t                    grp[group] = defaultSort;\n\t                    return grp;\n\t                } else if (angular.isObject(group)) {\n\t                    for (var key in group) {\n\t                        if (group[key] == null){\n\t                            group[key] = defaultSort;\n\t                        }\n\t                    }\n\t                    return group;\n\t                } else {\n\t                    return group;\n\t                }\n\t            }\n\t\n\t            /**\n\t             * @ngdoc method\n\t             * @name NgTableParams#settings\n\t             * @description Set new settings for table\n\t             *\n\t             * @param {string} newSettings New settings or undefined\n\t             * @returns {Object} Current settings or `this`\n\t             */\n\t            this.settings = function(newSettings) {\n\t                if (angular.isDefined(newSettings)) {\n\t\n\t                    // todo: don't modify newSettings object: this introduces unexpected side effects;\n\t                    // instead take a copy of newSettings\n\t\n\t                    if (newSettings.filterOptions){\n\t                        newSettings.filterOptions = angular.extend({}, settings.filterOptions, newSettings.filterOptions);\n\t                    }\n\t                    if (newSettings.groupOptions){\n\t                        newSettings.groupOptions = angular.extend({}, settings.groupOptions, newSettings.groupOptions);\n\t                    }\n\t\n\t                    if (angular.isArray(newSettings.dataset)) {\n\t                        //auto-set the total from passed in dataset\n\t                        newSettings.total = newSettings.dataset.length;\n\t                    }\n\t\n\t                    // todo: remove the backwards compatibility shim and the following two if blocks\n\t                    if (newSettings.getData && newSettings.getData.length > 1){\n\t                        // support the old getData($defer, params) api\n\t                        newSettings.getDataFnAdaptor = ngTableGetDataBcShim;\n\t                    }\n\t                    if (newSettings.getGroups && newSettings.getGroups.length > 2){\n\t                        // support the old getGroups($defer, params) api\n\t                        newSettings.getGroupsFnAdaptor = ngTableGetDataBcShim;\n\t                    }\n\t\n\t                    var originalDataset = settings.dataset;\n\t                    settings = angular.extend(settings, newSettings);\n\t\n\t                    if (angular.isArray(newSettings.dataset)) {\n\t                        optimizeFilterDelay();\n\t                    }\n\t\n\t                    // note: using != as want null and undefined to be treated the same\n\t                    var hasDatasetChanged = newSettings.hasOwnProperty('dataset') && (newSettings.dataset != originalDataset);\n\t                    if (hasDatasetChanged) {\n\t                        if (isCommittedDataset){\n\t                            this.page(1); // reset page as a new dataset has been supplied\n\t                        }\n\t                        isCommittedDataset = false;\n\t\n\t                        var fireEvent = function () {\n\t                            ngTableEventsChannel.publishDatasetChanged(self, newSettings.dataset, originalDataset);\n\t                        };\n\t\n\t                        if (initialEvents){\n\t                            initialEvents.push(fireEvent);\n\t                        } else {\n\t                            fireEvent();\n\t                        }\n\t                    }\n\t                    log('ngTable: set settings', settings);\n\t                    return this;\n\t                }\n\t                return settings;\n\t            };\n\t\n\t            /**\n\t             * @ngdoc method\n\t             * @name NgTableParams#page\n\t             * @description If parameter page not set return current page else set current page\n\t             *\n\t             * @param {string} page Page number\n\t             * @returns {Object|Number} Current page or `this`\n\t             */\n\t            this.page = function(page) {\n\t                return angular.isDefined(page) ? this.parameters({\n\t                    'page': page\n\t                }) : params.page;\n\t            };\n\t\n\t            /**\n\t             * @ngdoc method\n\t             * @name NgTableParams#total\n\t             * @description If parameter total not set return current quantity else set quantity\n\t             *\n\t             * @param {string} total Total quantity of items\n\t             * @returns {Object|Number} Current page or `this`\n\t             */\n\t            this.total = function(total) {\n\t                return angular.isDefined(total) ? this.settings({\n\t                    'total': total\n\t                }) : settings.total;\n\t            };\n\t\n\t            /**\n\t             * @ngdoc method\n\t             * @name NgTableParams#count\n\t             * @description If parameter count not set return current count per page else set count per page\n\t             *\n\t             * @param {string} count Count per number\n\t             * @returns {Object|Number} Count per page or `this`\n\t             */\n\t            this.count = function(count) {\n\t                // reset to first page because can be blank page\n\t                return angular.isDefined(count) ? this.parameters({\n\t                    'count': count,\n\t                    'page': 1\n\t                }) : params.count;\n\t            };\n\t\n\t            /**\n\t             * @ngdoc method\n\t             * @name NgTableParams#filter\n\t             * @description If 'filter' parameter not set return current filter else set current filter\n\t             *\n\t             * Note: when assigning a new filter, {@link NgTableParams#page page} will be set to 1\n\t             *\n\t             * @param {Object|Boolean} filter 'object': new filter to assign or\n\t             * 'true': to return the current filter minus any insignificant values (null,  undefined and empty string); or\n\t             * 'falsey': to return the current filter \"as is\"\n\t             * @returns {Object} Current filter or `this`\n\t             */\n\t            this.filter = function(filter) {\n\t                if (angular.isDefined(filter) && angular.isObject(filter)) {\n\t                    return this.parameters({\n\t                        'filter': filter,\n\t                        'page': 1\n\t                    });\n\t                } else if (filter === true){\n\t                    var keys = Object.keys(params.filter);\n\t                    var significantFilter = {};\n\t                    for (var i=0; i < keys.length; i++){\n\t                        var filterValue = params.filter[keys[i]];\n\t                        if (filterValue != null && filterValue !== '') {\n\t                            significantFilter[keys[i]] = filterValue;\n\t                        }\n\t                    }\n\t                    return significantFilter;\n\t                } else {\n\t                    return params.filter;\n\t                }\n\t            };\n\t\n\t            /**\n\t             * @ngdoc method\n\t             * @name NgTableParams#group\n\t             * @description If 'group' parameter is not set, return current grouping. Otherwise set current group.\n\t             *\n\t             * @param {string|Function|Object} group New group field\n\t             * @param {string} sortDirection Optional direction that the list of groups should be sorted\n\t             * @returns {Object} Current grouping or `this`\n\t             */\n\t            this.group = function(group, sortDirection) {\n\t                if (!angular.isDefined(group)){\n\t                    return params.group;\n\t                }\n\t\n\t                var newParameters = {\n\t                    page: 1\n\t                };\n\t                if (angular.isFunction(group) && angular.isDefined(sortDirection)){\n\t                    group.sortDirection = sortDirection;\n\t                    newParameters.group = group;\n\t                } else if (angular.isDefined(group) && angular.isDefined(sortDirection)) {\n\t                    var groupArray = {};\n\t                    groupArray[group] = sortDirection;\n\t                    newParameters.group = groupArray;\n\t                } else {\n\t                    newParameters.group = group;\n\t                }\n\t                this.parameters(newParameters);\n\t                return this;\n\t            };\n\t\n\t            /**\n\t             * @ngdoc method\n\t             * @name NgTableParams#sorting\n\t             * @description If 'sorting' parameter is not set, return current sorting. Otherwise set current sorting.\n\t             *\n\t             * @param {string} sorting New sorting\n\t             * @returns {Object} Current sorting or `this`\n\t             */\n\t            this.sorting = function(sorting) {\n\t                if (arguments.length == 2) {\n\t                    var sortArray = {};\n\t                    sortArray[sorting] = arguments[1];\n\t                    this.parameters({\n\t                        'sorting': sortArray\n\t                    });\n\t                    return this;\n\t                }\n\t                return angular.isDefined(sorting) ? this.parameters({\n\t                    'sorting': sorting\n\t                }) : params.sorting;\n\t            };\n\t\n\t            /**\n\t             * @ngdoc method\n\t             * @name NgTableParams#isSortBy\n\t             * @description Checks sort field\n\t             *\n\t             * @param {string} field     Field name\n\t             * @param {string} direction Optional direction of sorting ('asc' or 'desc')\n\t             * @returns {Array} Return true if field sorted by direction\n\t             */\n\t            this.isSortBy = function(field, direction) {\n\t                if(direction !== undefined) {\n\t                    return angular.isDefined(params.sorting[field]) && params.sorting[field] == direction;\n\t                } else {\n\t                    return angular.isDefined(params.sorting[field]);\n\t                }\n\t            };\n\t\n\t            /**\n\t             * @ngdoc method\n\t             * @name NgTableParams#orderBy\n\t             * @description Return object of sorting parameters for angular filter\n\t             *\n\t             * @returns {Array} Array like: [ '-name', '+age' ]\n\t             */\n\t            this.orderBy = function() {\n\t                return convertSortToOrderBy(params.sorting);\n\t            };\n\t\n\t            function convertSortToOrderBy(sorting){\n\t                var result = [];\n\t                for (var column in sorting) {\n\t                    result.push((sorting[column] === \"asc\" ? \"+\" : \"-\") + column);\n\t                }\n\t                return result;\n\t            }\n\t\n\t            /**\n\t             * @ngdoc method\n\t             * @name NgTableParams#generatePagesArray\n\t             * @description Generate array of pages\n\t             *\n\t             * When no arguments supplied, the current parameter state of this `NgTableParams` instance will be used\n\t             *\n\t             * @param {boolean} currentPage which page must be active\n\t             * @param {boolean} totalItems  Total quantity of items\n\t             * @param {boolean} pageSize    Quantity of items on page\n\t             * @param {number} maxBlocks    Quantity of blocks for pagination\n\t             * @returns {Array} Array of pages\n\t             */\n\t            this.generatePagesArray = function(currentPage, totalItems, pageSize, maxBlocks) {\n\t                if (!arguments.length){\n\t                    currentPage = this.page();\n\t                    totalItems = this.total();\n\t                    pageSize = this.count();\n\t                }\n\t\n\t                var maxPage, maxPivotPages, minPage, numPages, pages;\n\t                maxBlocks = maxBlocks && maxBlocks < 6 ? 6 : maxBlocks;\n\t\n\t                pages = [];\n\t                numPages = Math.ceil(totalItems / pageSize);\n\t                if (numPages > 1) {\n\t                    pages.push({\n\t                        type: 'prev',\n\t                        number: Math.max(1, currentPage - 1),\n\t                        active: currentPage > 1\n\t                    });\n\t                    pages.push({\n\t                        type: 'first',\n\t                        number: 1,\n\t                        active: currentPage > 1,\n\t                        current: currentPage === 1\n\t                    });\n\t                    maxPivotPages = Math.round((settings.paginationMaxBlocks - settings.paginationMinBlocks) / 2);\n\t                    minPage = Math.max(2, currentPage - maxPivotPages);\n\t                    maxPage = Math.min(numPages - 1, currentPage + maxPivotPages * 2 - (currentPage - minPage));\n\t                    minPage = Math.max(2, minPage - (maxPivotPages * 2 - (maxPage - minPage)));\n\t                    var i = minPage;\n\t                    while (i <= maxPage) {\n\t                        if ((i === minPage && i !== 2) || (i === maxPage && i !== numPages - 1)) {\n\t                            pages.push({\n\t                                type: 'more',\n\t                                active: false\n\t                            });\n\t                        } else {\n\t                            pages.push({\n\t                                type: 'page',\n\t                                number: i,\n\t                                active: currentPage !== i,\n\t                                current: currentPage === i\n\t                            });\n\t                        }\n\t                        i++;\n\t                    }\n\t                    pages.push({\n\t                        type: 'last',\n\t                        number: numPages,\n\t                        active: currentPage !== numPages,\n\t                        current: currentPage === numPages\n\t                    });\n\t                    pages.push({\n\t                        type: 'next',\n\t                        number: Math.min(numPages, currentPage + 1),\n\t                        active: currentPage < numPages\n\t                    });\n\t                }\n\t                return pages;\n\t            };\n\t\n\t            /**\n\t             * @ngdoc method\n\t             * @name NgTableParams#isDataReloadRequired\n\t             * @description Return true when a change to this `NgTableParams` instance should require the reload method\n\t             * to be run so as to ensure the data presented to the user reflects the `NgTableParams`\n\t             *\n\t             * Note that this method will return false when the reload method has run but fails. In this case\n\t             * `hasErrorState` will return true.\n\t             */\n\t            this.isDataReloadRequired = function(){\n\t                // note: using != as want to treat null and undefined the same\n\t                return !isCommittedDataset || !angular.equals(createComparableParams(), prevParamsMemento)\n\t                    || hasGlobalSearchFieldChanges();\n\t            };\n\t\n\t            function createComparableParams(){\n\t                var result = {params: params};\n\t                if (angular.isFunction(params.group)){\n\t                    result.groupSortDirection = params.group.sortDirection;\n\t                }\n\t                return result\n\t            }\n\t            /**\n\t             * @ngdoc method\n\t             * @name NgTableParams#hasFilter\n\t             * @description Determines if NgTableParams#filter has significant filter value(s)\n\t             * (any value except null, undefined, or empty string)\n\t             * @returns {Boolean} true when NgTableParams#filter has at least one significant field value\n\t             */\n\t            this.hasFilter = function(){\n\t                return Object.keys(this.filter(true)).length > 0;\n\t            };\n\t\n\t            /**\n\t             * @ngdoc method\n\t             * @name NgTableParams#hasGroup\n\t             * @description Determines if at least one group has been set\n\t             * @returns {Boolean}\n\t             */\n\t            this.hasGroup = function(group, sortDirection){\n\t                if (group == null) {\n\t                    return angular.isFunction(params.group) || Object.keys(params.group).length > 0\n\t                }\n\t\n\t                if (angular.isFunction(group)) {\n\t                    if (sortDirection == null) {\n\t                        return params.group === group;\n\t                    } else {\n\t                        return params.group === group && group.sortDirection === sortDirection;\n\t                    }\n\t                } else {\n\t                    if (sortDirection == null) {\n\t                        return Object.keys(params.group).indexOf(group) !== -1;\n\t                    } else {\n\t                        return params.group[group] === sortDirection;\n\t                    }\n\t                }\n\t            };\n\t\n\t            /**\n\t             * @ngdoc method\n\t             * @name NgTableParams#hasFilterChanges\n\t             * @description Return true when a change to `NgTableParams.filters`require the reload method\n\t             * to be run so as to ensure the data presented to the user reflects these filters\n\t             */\n\t            this.hasFilterChanges = function(){\n\t                var previousFilter = (prevParamsMemento && prevParamsMemento.params.filter);\n\t                return !angular.equals((params.filter), previousFilter) || hasGlobalSearchFieldChanges();\n\t            };\n\t\n\t            function hasGlobalSearchFieldChanges(){\n\t                var currentVal = (params.filter && params.filter.$);\n\t                var previousVal =\n\t                    (prevParamsMemento && prevParamsMemento.params.filter && prevParamsMemento.params.filter.$);\n\t                return !angular.equals(currentVal, previousVal);\n\t            }\n\t\n\t            /**\n\t             * @ngdoc method\n\t             * @name NgTableParams#url\n\t             * @description Return groups for table grouping\n\t             *\n\t             * @param {boolean} asString flag indicates return array of string or object\n\t             * @returns {Array} If asString = true will be return array of url string parameters else key-value object\n\t             */\n\t            this.url = function(asString) {\n\t                asString = asString || false;\n\t                var pairs = (asString ? [] : {});\n\t                for (var key in params) {\n\t                    if (params.hasOwnProperty(key)) {\n\t                        var item = params[key],\n\t                            name = encodeURIComponent(key);\n\t                        if (typeof item === \"object\") {\n\t                            for (var subkey in item) {\n\t                                if (isSignificantValue(item[subkey], key)) {\n\t                                    var pname = name + \"[\" + encodeURIComponent(subkey) + \"]\";\n\t                                    collectValue(item[subkey], pname);\n\t                                }\n\t                            }\n\t                        } else if (!angular.isFunction(item) && isSignificantValue(item, key)) {\n\t                            collectValue(item, name);\n\t                        }\n\t                    }\n\t                }\n\t                return pairs;\n\t\n\t                function collectValue(value, key){\n\t                    if (asString) {\n\t                        pairs.push(key + \"=\" + encodeURIComponent(value));\n\t                    } else {\n\t                        pairs[key] = encodeURIComponent(value);\n\t                    }\n\t                }\n\t\n\t                function isSignificantValue(value, key){\n\t                    return key === \"group\" ? true : angular.isDefined(value) && value !== \"\";\n\t                }\n\t            };\n\t\n\t            /**\n\t             * @ngdoc method\n\t             * @name NgTableParams#reload\n\t             * @description Reload table data\n\t             */\n\t            this.reload = function() {\n\t                var self = this,\n\t                    pData = null;\n\t\n\t                settings.$loading = true;\n\t\n\t                prevParamsMemento = angular.copy(createComparableParams());\n\t                isCommittedDataset = true;\n\t\n\t                if (self.hasGroup()) {\n\t                    pData = runInterceptorPipeline(runGetGroups);\n\t                } else {\n\t                    pData = runInterceptorPipeline(runGetData);\n\t                }\n\t\n\t                log('ngTable: reload data');\n\t\n\t                var oldData = self.data;\n\t                return pData.then(function(data) {\n\t                    settings.$loading = false;\n\t                    errParamsMemento = null;\n\t\n\t                    self.data = data;\n\t                    // note: I think it makes sense to publish this event even when data === oldData\n\t                    // subscribers can always set a filter to only receive the event when data !== oldData\n\t                    ngTableEventsChannel.publishAfterReloadData(self, data, oldData);\n\t                    self.reloadPages();\n\t\n\t                    // todo: remove after acceptable depreciation period\n\t                    if (settings.$scope) {\n\t                        settings.$scope.$emit('ngTableAfterReloadData');\n\t                    }\n\t\n\t                    return data;\n\t                }).catch(function(reason){\n\t                    errParamsMemento = prevParamsMemento;\n\t                    // \"rethrow\"\n\t                    return $q.reject(reason);\n\t                });\n\t            };\n\t\n\t            /**\n\t             * @ngdoc method\n\t             * @name NgTableParams#hasErrorState\n\t             * @description Return true when an attempt to `reload` the current `parameter` values have resulted in\n\t             * a failure\n\t             *\n\t             * This method will continue to return true until the reload is successfully called or when the\n\t             * `parameter` values have changed\n\t             */\n\t            this.hasErrorState = function(){\n\t                return !!(errParamsMemento && angular.equals(errParamsMemento, createComparableParams()));\n\t            };\n\t\n\t            function optimizeFilterDelay(){\n\t                // don't debounce by default filter input when working with small synchronous datasets\n\t                if (settings.filterOptions.filterDelay === defaultFilterOptions.filterDelay &&\n\t                    settings.total <= settings.filterOptions.filterDelayThreshold &&\n\t                    settings.getData === defaultSettingsFns.getData){\n\t                    settings.filterOptions.filterDelay = 0;\n\t                }\n\t            }\n\t\n\t            this.reloadPages = (function() {\n\t                var currentPages;\n\t                return function(){\n\t                    var oldPages = currentPages;\n\t                    var newPages = self.generatePagesArray(self.page(), self.total(), self.count());\n\t                    if (!angular.equals(oldPages, newPages)){\n\t                        currentPages = newPages;\n\t                        ngTableEventsChannel.publishPagesChanged(this, newPages, oldPages);\n\t                    }\n\t                }\n\t            })();\n\t\n\t            function runGetData(){\n\t                var getDataFn = settings.getDataFnAdaptor(settings.getData);\n\t                return $q.when(getDataFn.call(settings, self));\n\t            }\n\t\n\t            function runGetGroups(){\n\t                var getGroupsFn = settings.getGroupsFnAdaptor(settings.getGroups);\n\t                return $q.when(getGroupsFn.call(settings, self));\n\t            }\n\t\n\t            function runInterceptorPipeline(fetchFn){\n\t                var interceptors = settings.interceptors || [];\n\t\n\t                return interceptors.reduce(function(result, interceptor){\n\t                    var thenFn = (interceptor.response && interceptor.response.bind(interceptor)) || $q.when;\n\t                    var rejectFn = (interceptor.responseError && interceptor.responseError.bind(interceptor)) || $q.reject;\n\t                    return result.then(function(data){\n\t                        return thenFn(data, self);\n\t                    }, function(reason){\n\t                        return rejectFn(reason, self);\n\t                    });\n\t                }, fetchFn());\n\t            }\n\t\n\t            function getDefaultSettingFns(){\n\t\n\t                return {\n\t                    getDataFnAdaptor: angular.identity,\n\t                    getGroupsFnAdaptor: angular.identity,\n\t                    getData: getData,\n\t                    getGroups: getGroups\n\t                };\n\t\n\t                /**\n\t                 * @ngdoc method\n\t                 * @name settings#getData\n\t                 * @description Returns the data to display in the table\n\t                 *\n\t                 * Called by `NgTableParams` whenever it considers new data is to be loaded\n\t                 *\n\t                 * @param {Object} params the `NgTableParams` requesting data\n\t                 */\n\t                function getData(params) {\n\t                    return ngTableDefaultGetData(params.settings().dataset, params);\n\t                }\n\t\n\t                /**\n\t                 * @ngdoc method\n\t                 * @name settings#getGroups\n\t                 * @description Return groups of data to display in the table\n\t                 *\n\t                 * Called by `NgTableParams` whenever it considers new data is to be loaded\n\t                 * and when a `group` value has been assigned\n\t                 *\n\t                 * @param {Object} params the `NgTableParams` requesting data\n\t                 */\n\t                function getGroups(params) {\n\t\n\t                    var group = params.group();\n\t                    var groupFn;\n\t                    var sortDirection = undefined;\n\t                    if (angular.isFunction(group)) {\n\t                        groupFn = group;\n\t                        sortDirection = group.sortDirection;\n\t                    } else {\n\t                        // currently support for only one group implemented\n\t                        var groupField = Object.keys(group)[0];\n\t                        sortDirection = group[groupField];\n\t                        groupFn = function(item){\n\t                            return getPath(item, groupField);\n\t                        };\n\t                    }\n\t\n\t                    var settings = params.settings();\n\t                    var originalDataOptions = settings.dataOptions;\n\t                    settings.dataOptions = { applyPaging: false };\n\t                    var adaptedFn = settings.getDataFnAdaptor(settings.getData);\n\t                    var gotData = $q.when(adaptedFn.call(settings, params));\n\t                    return gotData.then(function(data) {\n\t                        var groups = {};\n\t                        angular.forEach(data, function(item) {\n\t                            var groupName = groupFn(item);\n\t                            groups[groupName] = groups[groupName] || {\n\t                                    data: [],\n\t                                    $hideRows: !settings.groupOptions.isExpanded,\n\t                                    value: groupName\n\t                                };\n\t                            groups[groupName].data.push(item);\n\t                        });\n\t                        var result = [];\n\t                        for (var i in groups) {\n\t                            result.push(groups[i]);\n\t                        }\n\t                        if (sortDirection) {\n\t                            var orderByFn = ngTableDefaultGetData.getOrderByFn();\n\t                            var orderBy = convertSortToOrderBy({\n\t                                value: sortDirection\n\t                            });\n\t                            result = orderByFn(result, orderBy);\n\t                        }\n\t\n\t                        return ngTableDefaultGetData.applyPaging(result, params);\n\t                    }).finally(function(){\n\t                        // restore the real options\n\t                        settings.dataOptions = originalDataOptions;\n\t                    });\n\t                }\n\t\n\t                function getPath (obj, ks) {\n\t                    // origianl source https://github.com/documentcloud/underscore-contrib\n\t\n\t                    if (typeof ks == \"string\") ks = ks.split(\".\");\n\t\n\t                    // If we have reached an undefined property\n\t                    // then stop executing and return undefined\n\t                    if (obj === undefined) return void 0;\n\t\n\t                    // If the path array has no more elements, we've reached\n\t                    // the intended property and return its value\n\t                    if (ks.length === 0) return obj;\n\t\n\t                    // If we still have elements in the path array and the current\n\t                    // value is null, stop executing and return undefined\n\t                    if (obj === null) return void 0;\n\t\n\t                    return getPath(obj[ks[0]], ks.slice(1));\n\t                }\n\t            }\n\t\n\t            var params = {\n\t                page: 1,\n\t                count: 10,\n\t                filter: {},\n\t                sorting: {},\n\t                group: {}\n\t            };\n\t            angular.extend(params, ngTableDefaults.params);\n\t\n\t            /**\n\t             * @ngdoc object\n\t             * @name settings\n\t             * @module ngTable\n\t             * @description configuration settings for `NgTableParams`\n\t             */\n\t            var settings = {\n\t                // todo: remove $scope after acceptable depreciation period as no longer required\n\t                $scope: null, // set by ngTable controller\n\t                $loading: false,\n\t                dataset: null, //allows data to be set when table is initialized\n\t                total: 0,\n\t                defaultSort: 'desc',\n\t                filterOptions: angular.copy(defaultFilterOptions),\n\t                groupOptions: angular.copy(defaultGroupOptions),\n\t                counts: [10, 25, 50, 100],\n\t                interceptors: [],\n\t                paginationMaxBlocks: 11,\n\t                paginationMinBlocks: 5,\n\t                sortingIndicator: 'span'\n\t            };\n\t\n\t            this.settings(defaultSettingsFns);\n\t            this.settings(ngTableDefaults.settings);\n\t            this.settings(baseSettings);\n\t            this.parameters(baseParameters, true);\n\t\n\t            ngTableEventsChannel.publishAfterCreated(this);\n\t            // run events during construction after the initial create event. That way a consumer\n\t            // can subscribe to all events for a table without \"dropping\" an event\n\t            angular.forEach(initialEvents, function(event){\n\t                event();\n\t            });\n\t            initialEvents = null;\n\t\n\t            return this;\n\t        };\n\t        return NgTableParams;\n\t    }]);\n\t\n\t    /**\n\t     * @ngdoc service\n\t     * @name ngTableParams\n\t     * @description Backwards compatible shim for lowercase 'n' in NgTableParams\n\t     */\n\t    angular.module('ngTable').factory('ngTableParams', ['NgTableParams', function(NgTableParams) {\n\t        return NgTableParams;\n\t    }]);\n\t})();\n\t\n\t\n\t\n\t/**\n\t * ngTable: Table + Angular JS\n\t *\n\t * @author Vitalii Savchuk <esvit666@gmail.com>\n\t * @url https://github.com/esvit/ng-table/\n\t * @license New BSD License <http://creativecommons.org/licenses/BSD/>\n\t */\n\t\n\t(function(){\n\t    /**\n\t     * @ngdoc object\n\t     * @name ngTableController\n\t     *\n\t     * @description\n\t     * Each {@link ngTable ngTable} directive creates an instance of `ngTableController`\n\t     */\n\t    angular.module('ngTable').controller('ngTableController', ['$scope', 'NgTableParams', '$timeout', '$parse', '$compile', '$attrs', '$element',\n\t        'ngTableColumn', 'ngTableEventsChannel',\n\t        function($scope, NgTableParams, $timeout, $parse, $compile, $attrs, $element, ngTableColumn, ngTableEventsChannel) {\n\t            var isFirstTimeLoad = true;\n\t            $scope.$filterRow = {};\n\t            $scope.$loading = false;\n\t\n\t            // until such times as the directive uses an isolated scope, we need to ensure that the check for\n\t            // the params field only consults the \"own properties\" of the $scope. This is to avoid seeing the params\n\t            // field on a $scope higher up in the prototype chain\n\t            if (!$scope.hasOwnProperty(\"params\")) {\n\t                $scope.params = new NgTableParams(true);\n\t            }\n\t            $scope.params.settings().$scope = $scope;\n\t\n\t            var delayFilter = (function() {\n\t                var timer = 0;\n\t                return function(callback, ms) {\n\t                    $timeout.cancel(timer);\n\t                    timer = $timeout(callback, ms);\n\t                };\n\t            })();\n\t\n\t            function onDataReloadStatusChange (newStatus/*, oldStatus*/) {\n\t                if (!newStatus || $scope.params.hasErrorState()) {\n\t                    return;\n\t                }\n\t\n\t                $scope.params.settings().$scope = $scope;\n\t\n\t                var currentParams = $scope.params;\n\t                var filterOptions = currentParams.settings().filterOptions;\n\t\n\t                if (currentParams.hasFilterChanges()) {\n\t                    var applyFilter = function () {\n\t                        currentParams.page(1);\n\t                        currentParams.reload();\n\t                    };\n\t                    if (filterOptions.filterDelay) {\n\t                        delayFilter(applyFilter, filterOptions.filterDelay);\n\t                    } else {\n\t                        applyFilter();\n\t                    }\n\t                } else {\n\t                    currentParams.reload();\n\t                }\n\t            }\n\t\n\t            // watch for when a new NgTableParams is bound to the scope\n\t            // CRITICAL: the watch must be for reference and NOT value equality; this is because NgTableParams maintains\n\t            // the current data page as a field. Checking this for value equality would be terrible for performance\n\t            // and potentially cause an error if the items in that array has circular references\n\t            $scope.$watch('params', function(newParams, oldParams){\n\t                if (newParams === oldParams || !newParams) {\n\t                    return;\n\t                }\n\t\n\t                newParams.reload();\n\t            }, false);\n\t\n\t            $scope.$watch('params.isDataReloadRequired()', onDataReloadStatusChange);\n\t\n\t            this.compileDirectiveTemplates = function () {\n\t                if (!$element.hasClass('ng-table')) {\n\t                    $scope.templates = {\n\t                        header: ($attrs.templateHeader ? $attrs.templateHeader : 'ng-table/header.html'),\n\t                        pagination: ($attrs.templatePagination ? $attrs.templatePagination : 'ng-table/pager.html')\n\t                    };\n\t                    $element.addClass('ng-table');\n\t                    var headerTemplate = null;\n\t\n\t                    // $element.find('> thead').length === 0 doesn't work on jqlite\n\t                    var theadFound = false;\n\t                    angular.forEach($element.children(), function(e) {\n\t                        if (e.tagName === 'THEAD') {\n\t                            theadFound = true;\n\t                        }\n\t                    });\n\t                    if (!theadFound) {\n\t                        headerTemplate = angular.element(document.createElement('thead')).attr('ng-include', 'templates.header');\n\t                        $element.prepend(headerTemplate);\n\t                    }\n\t                    var paginationTemplate = angular.element(document.createElement('div')).attr({\n\t                        'ng-table-pagination': 'params',\n\t                        'template-url': 'templates.pagination'\n\t                    });\n\t                    $element.after(paginationTemplate);\n\t                    if (headerTemplate) {\n\t                        $compile(headerTemplate)($scope);\n\t                    }\n\t                    $compile(paginationTemplate)($scope);\n\t                }\n\t            };\n\t\n\t            this.loadFilterData = function ($columns) {\n\t                angular.forEach($columns, function ($column) {\n\t                    var result;\n\t                    result = $column.filterData($scope);\n\t                    if (!result) {\n\t                        delete $column.filterData;\n\t                        return;\n\t                    }\n\t\n\t                    // if we're working with a deferred object or a promise, let's wait for the promise\n\t                    /* WARNING: support for returning a $defer is depreciated */\n\t                    if ((angular.isObject(result) && (angular.isObject(result.promise) || angular.isFunction(result.then)))) {\n\t                        var pData = angular.isFunction(result.then) ? result : result.promise;\n\t                        delete $column.filterData;\n\t                        return pData.then(function(data) {\n\t                            // our deferred can eventually return arrays, functions and objects\n\t                            if (!angular.isArray(data) && !angular.isFunction(data) && !angular.isObject(data)) {\n\t                                // if none of the above was found - we just want an empty array\n\t                                data = [];\n\t                            }\n\t                            $column.data = data;\n\t                        });\n\t                    }\n\t                    // otherwise, we just return what the user gave us. It could be a function, array, object, whatever\n\t                    else {\n\t                        return $column.data = result;\n\t                    }\n\t                });\n\t            };\n\t\n\t            this.buildColumns = function (columns) {\n\t                var result = [];\n\t                (columns || []).forEach(function(col){\n\t                    result.push(ngTableColumn.buildColumn(col, $scope, result));\n\t                });\n\t                return result\n\t            };\n\t\n\t            this.parseNgTableDynamicExpr = function (attr) {\n\t                if (!attr || attr.indexOf(\" with \") > -1) {\n\t                    var parts = attr.split(/\\s+with\\s+/);\n\t                    return {\n\t                        tableParams: parts[0],\n\t                        columns: parts[1]\n\t                    };\n\t                } else {\n\t                    throw new Error('Parse error (expected example: ng-table-dynamic=\\'tableParams with cols\\')');\n\t                }\n\t            };\n\t\n\t            this.setupBindingsToInternalScope = function(tableParamsExpr){\n\t\n\t                // note: this we're setting up watches to simulate angular's isolated scope bindings\n\t\n\t                // note: is REALLY important to watch for a change to the ngTableParams *reference* rather than\n\t                // $watch for value equivalence. This is because ngTableParams references the current page of data as\n\t                // a field and it's important not to watch this\n\t                var tableParamsGetter = $parse(tableParamsExpr);\n\t                $scope.$watch(tableParamsGetter, (function (params) {\n\t                    if (angular.isUndefined(params)) {\n\t                        return;\n\t                    }\n\t                    $scope.paramsModel = tableParamsGetter;\n\t                    $scope.params = params;\n\t                }), false);\n\t\n\t                setupFilterRowBindingsToInternalScope();\n\t                setupGroupRowBindingsToInternalScope();\n\t            };\n\t\n\t            function setupFilterRowBindingsToInternalScope(){\n\t                if ($attrs.showFilter) {\n\t                    $scope.$parent.$watch($attrs.showFilter, function(value) {\n\t                        $scope.show_filter = value;\n\t                    });\n\t                } else {\n\t                    $scope.$watch(hasVisibleFilterColumn, function(value){\n\t                        $scope.show_filter = value;\n\t                    })\n\t                }\n\t\n\t                if ($attrs.disableFilter) {\n\t                    $scope.$parent.$watch($attrs.disableFilter, function(value) {\n\t                        $scope.$filterRow.disabled = value;\n\t                    });\n\t                }\n\t            }\n\t\n\t            function setupGroupRowBindingsToInternalScope(){\n\t                $scope.$groupRow = {};\n\t                if ($attrs.showGroup) {\n\t                    var showGroupGetter = $parse($attrs.showGroup);\n\t                    $scope.$parent.$watch(showGroupGetter, function(value) {\n\t                        $scope.$groupRow.show = value;\n\t                    });\n\t                    if (showGroupGetter.assign){\n\t                        // setup two-way databinding thus allowing ngTableGrowRow to assign to the showGroup expression\n\t                        $scope.$watch('$groupRow.show', function(value) {\n\t                            showGroupGetter.assign($scope.$parent, value);\n\t                        });\n\t                    }\n\t                } else{\n\t                    $scope.$watch('params.hasGroup()', function(newValue) {\n\t                        $scope.$groupRow.show = newValue;\n\t                    });\n\t                }\n\t            }\n\t\n\t            function getVisibleColumns(){\n\t                return ($scope.$columns || []).filter(function(c){\n\t                    return c.show($scope);\n\t                });\n\t            }\n\t\n\t            function hasVisibleFilterColumn(){\n\t                if (!$scope.$columns) return false;\n\t\n\t                return some($scope.$columns, function($column){\n\t                    return $column.show($scope) && $column.filter($scope);\n\t                });\n\t            }\n\t\n\t            function some(array, predicate){\n\t                var found = false;\n\t                for (var i = 0; i < array.length; i++) {\n\t                    var obj = array[i];\n\t                    if (predicate(obj)){\n\t                        found = true;\n\t                        break;\n\t                    }\n\t                }\n\t                return found;\n\t            }\n\t\n\t            function commonInit(){\n\t                ngTableEventsChannel.onAfterReloadData(bindDataToScope, $scope, isMyPublisher);\n\t                ngTableEventsChannel.onPagesChanged(bindPagesToScope, $scope, isMyPublisher);\n\t\n\t                function bindDataToScope(params, newDatapage){\n\t                    var visibleColumns = getVisibleColumns();\n\t                    if (params.hasGroup()) {\n\t                        $scope.$groups = newDatapage || [];\n\t                        $scope.$groups.visibleColumnCount = visibleColumns.length;\n\t                    } else {\n\t                        $scope.$data = newDatapage || [];\n\t                        $scope.$data.visibleColumnCount = visibleColumns.length;\n\t                    }\n\t                }\n\t\n\t                function bindPagesToScope(params, newPages){\n\t                    $scope.pages = newPages\n\t                }\n\t\n\t                function isMyPublisher(publisher){\n\t                    return $scope.params === publisher;\n\t                }\n\t            }\n\t\n\t            commonInit();\n\t        }]);\n\t})();\n\t\n\t/**\n\t * ngTable: Table + Angular JS\n\t *\n\t * @author Vitalii Savchuk <esvit666@gmail.com>\n\t * @url https://github.com/esvit/ng-table/\n\t * @license New BSD License <http://creativecommons.org/licenses/BSD/>\n\t */\n\t\n\t(function(){\n\t    /**\n\t     * @ngdoc directive\n\t     * @name ngTable\n\t     * @module ngTable\n\t     * @restrict A\n\t     *\n\t     * @description\n\t     * Directive that instantiates {@link ngTableController ngTableController}.\n\t     */\n\t    angular.module('ngTable').directive('ngTable', ['$q', '$parse',\n\t        function($q, $parse) {\n\t            'use strict';\n\t\n\t            return {\n\t                restrict: 'A',\n\t                priority: 1001,\n\t                scope: true,\n\t                controller: 'ngTableController',\n\t                compile: function(element) {\n\t                    var columns = [],\n\t                        i = 0,\n\t                        dataRow,\n\t                        groupRow,\n\t                        rows = [];\n\t\n\t                    angular.forEach(element.find('tr'), function(tr) {\n\t                        rows.push(angular.element(tr))\n\t                    });\n\t                    dataRow = rows.filter(function(tr){\n\t                        return !tr.hasClass('ng-table-group');\n\t                    })[0];\n\t                    groupRow = rows.filter(function(tr){\n\t                        return tr.hasClass('ng-table-group');\n\t                    })[0];\n\t\n\t                    if (!dataRow) {\n\t                        return;\n\t                    }\n\t                    angular.forEach(dataRow.find('td'), function(item) {\n\t                        var el = angular.element(item);\n\t                        if (el.attr('ignore-cell') && 'true' === el.attr('ignore-cell')) {\n\t                            return;\n\t                        }\n\t\n\t                        var getAttrValue = function(attr){\n\t                            return el.attr('x-data-' + attr) || el.attr('data-' + attr) || el.attr(attr);\n\t                        };\n\t                        var setAttrValue = function(attr, value){\n\t                            if (el.attr('x-data-' + attr)){\n\t                                el.attr('x-data-' + attr, value)\n\t                            } else if (el.attr('data' + attr)){\n\t                                el.attr('data' + attr, value)\n\t                            } else {\n\t                                el.attr(attr, value)\n\t                            }\n\t                        };\n\t\n\t                        var parsedAttribute = function(attr) {\n\t                            var expr = getAttrValue(attr);\n\t                            if (!expr){\n\t                                return undefined;\n\t                            }\n\t\n\t                            var localValue;\n\t                            var getter = function (context) {\n\t                                if (localValue !== undefined){\n\t                                    return localValue;\n\t                                }\n\t                                return $parse(expr)(context);\n\t                            };\n\t                            getter.assign = function($scope, value){\n\t                                var parsedExpr = $parse(expr);\n\t                                if (parsedExpr.assign) {\n\t                                    // we should be writing back to the parent scope as this is where the expression\n\t                                    // came from\n\t                                    parsedExpr.assign($scope.$parent, value);\n\t                                } else {\n\t                                    localValue = value;\n\t                                }\n\t                            };\n\t                            return getter;\n\t                        };\n\t                        var titleExpr = getAttrValue('title-alt') || getAttrValue('title');\n\t                        if (titleExpr){\n\t                            el.attr('data-title-text', '{{' + titleExpr + '}}'); // this used in responsive table\n\t                        }\n\t                        // NOTE TO MAINTAINERS: if you add extra fields to a $column be sure to extend ngTableColumn with\n\t                        // a corresponding \"safe\" default\n\t                        columns.push({\n\t                            id: i++,\n\t                            title: parsedAttribute('title'),\n\t                            titleAlt: parsedAttribute('title-alt'),\n\t                            headerTitle: parsedAttribute('header-title'),\n\t                            sortable: parsedAttribute('sortable'),\n\t                            'class': parsedAttribute('header-class'),\n\t                            filter: parsedAttribute('filter'),\n\t                            groupable: parsedAttribute('groupable'),\n\t                            headerTemplateURL: parsedAttribute('header'),\n\t                            filterData: parsedAttribute('filter-data'),\n\t                            show: el.attr(\"ng-if\") ? parsedAttribute('ng-if') : undefined\n\t                        });\n\t\n\t                        if (groupRow || el.attr(\"ng-if\")){\n\t                            // change ng-if to bind to our column definition which we know will be writable\n\t                            // because this will potentially increase the $watch count, only do so if we already have an\n\t                            // ng-if or when we definitely need to change visibility of the columns.\n\t                            // currently only ngTableGroupRow directive needs to change visibility\n\t                            setAttrValue('ng-if', '$columns[' + (columns.length - 1) + '].show(this)');\n\t                        }\n\t                    });\n\t                    return function(scope, element, attrs, controller) {\n\t                        scope.$columns = columns = controller.buildColumns(columns);\n\t\n\t                        controller.setupBindingsToInternalScope(attrs.ngTable);\n\t                        controller.loadFilterData(columns);\n\t                        controller.compileDirectiveTemplates();\n\t                    };\n\t                }\n\t            }\n\t        }\n\t    ]);\n\t})();\n\t\n\t/**\n\t * ngTable: Table + Angular JS\n\t *\n\t * @author Vitalii Savchuk <esvit666@gmail.com>\n\t * @url https://github.com/esvit/ng-table/\n\t * @license New BSD License <http://creativecommons.org/licenses/BSD/>\n\t */\n\t\n\t(function(){\n\t\n\t    /**\n\t     * @ngdoc directive\n\t     * @name ngTableDynamic\n\t     * @module ngTable\n\t     * @restrict A\n\t     *\n\t     * @description\n\t     * A dynamic version of the {@link ngTable ngTable} directive that accepts a dynamic list of columns\n\t     * definitions to render\n\t     */\n\t    angular.module('ngTable').directive('ngTableDynamic', [function (){\n\t\n\t        return {\n\t            restrict: 'A',\n\t            priority: 1001,\n\t            scope: true,\n\t            controller: 'ngTableController',\n\t            compile: function(tElement) {\n\t                var row;\n\t\n\t                // IE 8 fix :not(.ng-table-group) selector\n\t                angular.forEach(tElement.find('tr'), function(tr) {\n\t                    tr = angular.element(tr);\n\t                    if (!tr.hasClass('ng-table-group') && !row) {\n\t                        row = tr;\n\t                    }\n\t                });\n\t                if (!row) {\n\t                    return;\n\t                }\n\t\n\t                angular.forEach(row.find('td'), function(item) {\n\t                    var el = angular.element(item);\n\t                    var getAttrValue = function(attr){\n\t                        return el.attr('x-data-' + attr) || el.attr('data-' + attr) || el.attr(attr);\n\t                    };\n\t\n\t                    // this used in responsive table\n\t                    var titleExpr = getAttrValue('title');\n\t                    if (!titleExpr){\n\t                        el.attr('data-title-text', '{{$columns[$index].titleAlt(this) || $columns[$index].title(this)}}');\n\t                    }\n\t                    var showExpr = el.attr('ng-if');\n\t                    if (!showExpr){\n\t                        el.attr('ng-if', '$columns[$index].show(this)');\n\t                    }\n\t                });\n\t                return function (scope, element, attrs, controller) {\n\t                    var expr = controller.parseNgTableDynamicExpr(attrs.ngTableDynamic);\n\t\n\t                    controller.setupBindingsToInternalScope(expr.tableParams);\n\t                    controller.compileDirectiveTemplates();\n\t\n\t                    scope.$watchCollection(expr.columns, function (newCols/*, oldCols*/) {\n\t                        scope.$columns = controller.buildColumns(newCols);\n\t                        controller.loadFilterData(scope.$columns);\n\t                    });\n\t                };\n\t            }\n\t        };\n\t    }]);\n\t})();\n\t\n\t/**\n\t * ngTable: Table + Angular JS\n\t *\n\t * @author Vitalii Savchuk <esvit666@gmail.com>\n\t * @url https://github.com/esvit/ng-table/\n\t * @license New BSD License <http://creativecommons.org/licenses/BSD/>\n\t */\n\t\n\t(function(){\n\t    'use strict';\n\t\n\t    angular.module('ngTable')\n\t        .directive('ngTableColumnsBinding', ngTableColumnsBinding);\n\t\n\t    ngTableColumnsBinding.$inject = [\"$parse\"];\n\t\n\t    /**\n\t     * @ngdoc directive\n\t     * @name ngTableColumnsBinding\n\t     * @description One-way data binds the $columns array generated by ngTable/ngTableDynamic to the specified\n\t     * expression.\n\t     *\n\t     * This allows the $columns array to be accessed outside of the html table markup\n\t     */\n\t    function ngTableColumnsBinding($parse){\n\t        var directive = {\n\t            restrict: 'A',\n\t            require: 'ngTable',\n\t            link: linkFn\n\t        };\n\t        return directive;\n\t\n\t        function linkFn($scope, $element, $attrs){\n\t            var setter = $parse($attrs.ngTableColumnsBinding).assign;\n\t            if (setter){\n\t                $scope.$watch('$columns', function(newColumns){\n\t                    var shallowClone = (newColumns || []).slice(0);\n\t                    setter($scope, shallowClone);\n\t                });\n\t            }\n\t        }\n\t    }\n\t})();\n\t\n\t/**\n\t * ngTable: Table + Angular JS\n\t *\n\t * @author Vitalii Savchuk <esvit666@gmail.com>\n\t * @url https://github.com/esvit/ng-table/\n\t * @license New BSD License <http://creativecommons.org/licenses/BSD/>\n\t */\n\t\n\t(function(){\n\t    /**\n\t     * @ngdoc directive\n\t     * @name ngTablePagination\n\t     * @module ngTable\n\t     * @restrict A\n\t     */\n\t    angular.module('ngTable').directive('ngTablePagination', ['$compile', 'ngTableEventsChannel',\n\t        function($compile, ngTableEventsChannel) {\n\t            'use strict';\n\t\n\t            return {\n\t                restrict: 'A',\n\t                scope: {\n\t                    'params': '=ngTablePagination',\n\t                    'templateUrl': '='\n\t                },\n\t                replace: false,\n\t                link: function(scope, element/*, attrs*/) {\n\t\n\t                    ngTableEventsChannel.onAfterReloadData(function(pubParams) {\n\t                        scope.pages = pubParams.generatePagesArray();\n\t                    }, scope, function(pubParams){\n\t                        return pubParams === scope.params;\n\t                    });\n\t\n\t                    scope.$watch('templateUrl', function(templateUrl) {\n\t                        if (angular.isUndefined(templateUrl)) {\n\t                            return;\n\t                        }\n\t                        var template = angular.element(document.createElement('div'));\n\t                        template.attr({\n\t                            'ng-include': 'templateUrl'\n\t                        });\n\t                        element.append(template);\n\t                        $compile(template)(scope);\n\t                    });\n\t                }\n\t            };\n\t        }\n\t    ]);\n\t\n\t})();\n\t\n\t/**\n\t * ngTable: Table + Angular JS\n\t *\n\t * @author Vitalii Savchuk <esvit666@gmail.com>\n\t * @url https://github.com/esvit/ng-table/\n\t * @license New BSD License <http://creativecommons.org/licenses/BSD/>\n\t */\n\t\n\t(function(){\n\t    'use strict';\n\t\n\t    angular.module('ngTable')\n\t        .controller('ngTableFilterRowController', ngTableFilterRowController);\n\t\n\t    ngTableFilterRowController.$inject = ['$scope', 'ngTableFilterConfig'];\n\t\n\t    function ngTableFilterRowController($scope, ngTableFilterConfig){\n\t\n\t        $scope.config = ngTableFilterConfig;\n\t\n\t        $scope.getFilterCellCss = function (filter, layout){\n\t            if (layout !== 'horizontal') {\n\t                return 's12';\n\t            }\n\t\n\t            var size = Object.keys(filter).length;\n\t            var width = parseInt(12 / size, 10);\n\t            return 's' + width;\n\t        };\n\t\n\t        $scope.getFilterPlaceholderValue = function(filterValue/*, filterName*/){\n\t            if (angular.isObject(filterValue)) {\n\t                return filterValue.placeholder;\n\t            } else {\n\t                return '';\n\t            }\n\t        };\n\t    }\n\t})();\n\t\n\t/**\n\t * ngTable: Table + Angular JS\n\t *\n\t * @author Vitalii Savchuk <esvit666@gmail.com>\n\t * @url https://github.com/esvit/ng-table/\n\t * @license New BSD License <http://creativecommons.org/licenses/BSD/>\n\t */\n\t\n\t(function(){\n\t    'use strict';\n\t\n\t    angular.module('ngTable')\n\t        .directive('ngTableFilterRow', ngTableFilterRow);\n\t\n\t    ngTableFilterRow.$inject = [];\n\t\n\t    function ngTableFilterRow(){\n\t        var directive = {\n\t            restrict: 'E',\n\t            replace: true,\n\t            templateUrl: 'ng-table/filterRow.html',\n\t            scope: true,\n\t            controller: 'ngTableFilterRowController'\n\t        };\n\t        return directive;\n\t    }\n\t})();\n\t\n\t/**\n\t * ngTable: Table + Angular JS\n\t *\n\t * @author Vitalii Savchuk <esvit666@gmail.com>\n\t * @url https://github.com/esvit/ng-table/\n\t * @license New BSD License <http://creativecommons.org/licenses/BSD/>\n\t */\n\t\n\t(function(){\n\t    'use strict';\n\t\n\t    angular.module('ngTable')\n\t        .controller('ngTableGroupRowController', ngTableGroupRowController);\n\t\n\t    ngTableGroupRowController.$inject = ['$scope'];\n\t\n\t    function ngTableGroupRowController($scope){\n\t\n\t        var groupFns = [];\n\t\n\t        init();\n\t\n\t        function init(){\n\t            $scope.getGroupables = getGroupables;\n\t            $scope.getGroupTitle = getGroupTitle;\n\t            $scope.getVisibleColumns = getVisibleColumns;\n\t            $scope.groupBy = groupBy;\n\t            $scope.isSelectedGroup = isSelectedGroup;\n\t            $scope.toggleDetail = toggleDetail;\n\t\n\t            $scope.$watch('params.group()', setGroup, true);\n\t        }\n\t\n\t        function changeSortDirection(){\n\t            var newDirection;\n\t            if ($scope.params.hasGroup($scope.$selGroup, 'asc')) {\n\t                newDirection = 'desc';\n\t            } else if ($scope.params.hasGroup($scope.$selGroup, 'desc')){\n\t                newDirection = '';\n\t            } else {\n\t                newDirection = 'asc';\n\t            }\n\t            $scope.params.group($scope.$selGroup, newDirection);\n\t        }\n\t\n\t        function findGroupColumn(groupKey) {\n\t            return $scope.$columns.filter(function ($column) {\n\t                return $column.groupable($scope) === groupKey;\n\t            })[0];\n\t        }\n\t\n\t        function getGroupTitle(group){\n\t            return angular.isFunction(group) ? group.title : group.title($scope);\n\t        }\n\t\n\t        function getGroupables(){\n\t            var groupableCols = $scope.$columns.filter(function ($column) {\n\t                return $column.groupable($scope);\n\t            });\n\t            return groupFns.concat(groupableCols);\n\t        }\n\t\n\t        function getVisibleColumns(){\n\t            return $scope.$columns.filter(function($column){\n\t                return $column.show($scope);\n\t            })\n\t        }\n\t\n\t        function groupBy(group){\n\t            if (isSelectedGroup(group)){\n\t                changeSortDirection();\n\t            } else {\n\t                if (group.groupable){\n\t                    $scope.params.group(group.groupable($scope));\n\t                } else{\n\t                    $scope.params.group(group);\n\t                }\n\t            }\n\t        }\n\t\n\t        function isSelectedGroup(group){\n\t            if (group.groupable){\n\t                return group.groupable($scope) === $scope.$selGroup;\n\t            } else {\n\t                return group === $scope.$selGroup;\n\t            }\n\t        }\n\t\n\t        function setGroup(group){\n\t            var existingGroupCol = findGroupColumn($scope.$selGroup);\n\t            if (existingGroupCol && existingGroupCol.show.assign){\n\t                existingGroupCol.show.assign($scope, true);\n\t            }\n\t            if (angular.isFunction(group)) {\n\t                groupFns = [group];\n\t                $scope.$selGroup = group;\n\t                $scope.$selGroupTitle = group.title;\n\t            } else {\n\t                // note: currently only one group is implemented\n\t                var groupKey = Object.keys(group || {})[0];\n\t                var groupedColumn = findGroupColumn(groupKey);\n\t                if (groupedColumn) {\n\t                    $scope.$selGroupTitle = groupedColumn.title($scope);\n\t                    $scope.$selGroup = groupKey;\n\t                    if (groupedColumn.show.assign) {\n\t                        groupedColumn.show.assign($scope, false);\n\t                    }\n\t                }\n\t            }\n\t        }\n\t\n\t        function toggleDetail(){\n\t            $scope.params.settings().groupOptions.isExpanded = !$scope.params.settings().groupOptions.isExpanded;\n\t            return $scope.params.reload();\n\t        }\n\t    }\n\t})();\n\t\n\t/**\n\t * ngTable: Table + Angular JS\n\t *\n\t * @author Vitalii Savchuk <esvit666@gmail.com>\n\t * @url https://github.com/esvit/ng-table/\n\t * @license New BSD License <http://creativecommons.org/licenses/BSD/>\n\t */\n\t\n\t(function(){\n\t    'use strict';\n\t\n\t    angular.module('ngTable')\n\t        .directive('ngTableGroupRow', ngTableGroupRow);\n\t\n\t    ngTableGroupRow.$inject = [];\n\t\n\t    function ngTableGroupRow(){\n\t        var directive = {\n\t            restrict: 'E',\n\t            replace: true,\n\t            templateUrl: 'ng-table/groupRow.html',\n\t            scope: true,\n\t            controller: 'ngTableGroupRowController',\n\t            controllerAs: 'dctrl'\n\t        };\n\t        return directive;\n\t    }\n\t})();\n\t\n\t/**\n\t * ngTable: Table + Angular JS\n\t *\n\t * @author Vitalii Savchuk <esvit666@gmail.com>\n\t * @url https://github.com/esvit/ng-table/\n\t * @license New BSD License <http://creativecommons.org/licenses/BSD/>\n\t */\n\t\n\t(function(){\n\t    'use strict';\n\t\n\t    angular.module('ngTable')\n\t        .controller('ngTableSorterRowController', ngTableSorterRowController);\n\t\n\t    ngTableSorterRowController.$inject = ['$scope'];\n\t\n\t    function ngTableSorterRowController($scope){\n\t\n\t        $scope.sortBy = sortBy;\n\t\n\t        ///////////\n\t\n\t        function sortBy($column, event) {\n\t            var parsedSortable = $column.sortable && $column.sortable();\n\t            if (!parsedSortable) {\n\t                return;\n\t            }\n\t            var defaultSort = $scope.params.settings().defaultSort;\n\t            var inverseSort = (defaultSort === 'asc' ? 'desc' : 'asc');\n\t            var sorting = $scope.params.sorting() && $scope.params.sorting()[parsedSortable] && ($scope.params.sorting()[parsedSortable] === defaultSort);\n\t            var sortingParams = (event.ctrlKey || event.metaKey) ? $scope.params.sorting() : {};\n\t            sortingParams[parsedSortable] = (sorting ? inverseSort : defaultSort);\n\t            $scope.params.parameters({\n\t                sorting: sortingParams\n\t            });\n\t        }\n\t    }\n\t})();\n\t\n\t/**\n\t * ngTable: Table + Angular JS\n\t *\n\t * @author Vitalii Savchuk <esvit666@gmail.com>\n\t * @url https://github.com/esvit/ng-table/\n\t * @license New BSD License <http://creativecommons.org/licenses/BSD/>\n\t */\n\t\n\t(function(){\n\t    'use strict';\n\t\n\t    angular.module('ngTable')\n\t        .directive('ngTableSorterRow', ngTableSorterRow);\n\t\n\t    ngTableSorterRow.$inject = [];\n\t\n\t    function ngTableSorterRow(){\n\t        var directive = {\n\t            restrict: 'E',\n\t            replace: true,\n\t            templateUrl: 'ng-table/sorterRow.html',\n\t            scope: true,\n\t            controller: 'ngTableSorterRowController'\n\t        };\n\t        return directive;\n\t    }\n\t})();\n\t\n\t/**\n\t * ngTable: Table + Angular JS\n\t *\n\t * @author Vitalii Savchuk <esvit666@gmail.com>\n\t * @url https://github.com/esvit/ng-table/\n\t * @license New BSD License <http://creativecommons.org/licenses/BSD/>\n\t */\n\t\n\t(function(){\n\t    'use strict';\n\t\n\t    /**\n\t     * @ngdoc directive\n\t     * @name ngTableSelectFilterDs\n\t     * @module ngTable\n\t     * @restrict A\n\t     *\n\t     * @description\n\t     * Takes the array returned by $column.filterData and makes it available as `$selectData` on the `$scope`.\n\t     *\n\t     * The resulting `$selectData` array will contain an extra item that is suitable to represent the user\n\t     * \"deselecting\" an item from a `<select>` tag\n\t     *\n\t     * This directive is is focused on providing a datasource to an `ngOptions` directive\n\t     */\n\t    angular.module('ngTable')\n\t        .directive('ngTableSelectFilterDs', ngTableSelectFilterDs);\n\t\n\t    ngTableSelectFilterDs.$inject = [];\n\t\n\t    function ngTableSelectFilterDs(){\n\t        // note: not using isolated or child scope \"by design\"\n\t        // this is to allow this directive to be combined with other directives that do\n\t\n\t        var directive = {\n\t            restrict: 'A',\n\t            controller: ngTableSelectFilterDsController\n\t        };\n\t        return directive;\n\t    }\n\t\n\t    ngTableSelectFilterDsController.$inject = ['$scope', '$parse', '$attrs', '$q'];\n\t    function ngTableSelectFilterDsController($scope, $parse, $attrs, $q){\n\t\n\t        var $column = {};\n\t        init();\n\t\n\t        function init(){\n\t            $column = $parse($attrs.ngTableSelectFilterDs)($scope);\n\t            $scope.$watch(function(){\n\t                return $column.data;\n\t            }, bindDataSource);\n\t        }\n\t\n\t        function bindDataSource(){\n\t            getSelectListData($column).then(function(data){\n\t                if (data && !hasEmptyOption(data)){\n\t                    data.unshift({ id: '', title: ''});\n\t                }\n\t                data = data || [];\n\t                $scope.$selectData = data;\n\t            });\n\t        }\n\t\n\t        function hasEmptyOption(data) {\n\t            var isMatch;\n\t            for (var i = 0; i < data.length; i++) {\n\t                var item = data[i];\n\t                if (item && item.id === '') {\n\t                    isMatch = true;\n\t                    break;\n\t                }\n\t            }\n\t            return isMatch;\n\t        }\n\t\n\t        function getSelectListData($column) {\n\t            var data = angular.isFunction($column.data) ? $column.data() : $column.data;\n\t            return $q.when(data);\n\t        }\n\t    }\n\t})();\n\t\n\tangular.module('ngTable').run(['$templateCache', function ($templateCache) {\n\t\t$templateCache.put('ng-table/filterRow.html', '<tr ng-show=\"show_filter\" class=\"ng-table-filters\"> <th data-title-text=\"{{$column.titleAlt(this) || $column.title(this)}}\" ng-repeat=\"$column in $columns\" ng-if=\"$column.show(this)\" class=\"filter {{$column.class(this)}}\" ng-class=\"params.settings().filterOptions.filterLayout===\\'horizontal\\' ? \\'filter-horizontal\\' : \\'\\'\"> <div ng-repeat=\"(name, filter) in $column.filter(this)\" ng-include=\"config.getTemplateUrl(filter)\" class=\"filter-cell\" ng-class=\"[getFilterCellCss($column.filter(this), params.settings().filterOptions.filterLayout), $last ? \\'last\\' : \\'\\']\"> </div> </th> </tr> ');\n\t\t$templateCache.put('ng-table/filters/number.html', '<input type=\"number\" name=\"{{name}}\" ng-disabled=\"$filterRow.disabled\" ng-model=\"params.filter()[name]\" class=\"input-filter form-control\" placeholder=\"{{getFilterPlaceholderValue(filter, name)}}\"/> ');\n\t\t$templateCache.put('ng-table/filters/select-multiple.html', '<select ng-options=\"data.id as data.title for data in $column.data\" ng-disabled=\"$filterRow.disabled\" multiple ng-multiple=\"true\" ng-model=\"params.filter()[name]\" class=\"filter filter-select-multiple form-control\" name=\"{{name}}\"> </select> ');\n\t\t$templateCache.put('ng-table/filters/select.html', '<select ng-options=\"data.id as data.title for data in $selectData\" ng-table-select-filter-ds=\"$column\" ng-disabled=\"$filterRow.disabled\" ng-model=\"params.filter()[name]\" class=\"filter filter-select form-control\" name=\"{{name}}\"> <option style=\"display:none\" value=\"\"></option> </select> ');\n\t\t$templateCache.put('ng-table/filters/text.html', '<input type=\"text\" name=\"{{name}}\" ng-disabled=\"$filterRow.disabled\" ng-model=\"params.filter()[name]\" class=\"input-filter form-control\" placeholder=\"{{getFilterPlaceholderValue(filter, name)}}\"/> ');\n\t\t$templateCache.put('ng-table/groupRow.html', '<tr ng-if=\"params.hasGroup()\" ng-show=\"$groupRow.show\" class=\"ng-table-group-header\"> <th colspan=\"{{getVisibleColumns().length}}\" class=\"sortable\" ng-class=\"{ \\'sort-asc\\': params.hasGroup($selGroup, \\'asc\\'), \\'sort-desc\\':params.hasGroup($selGroup, \\'desc\\') }\"> <a href=\"\" ng-click=\"isSelectorOpen=!isSelectorOpen\" class=\"ng-table-group-selector\"> <strong class=\"sort-indicator\">{{$selGroupTitle}}</strong> <button class=\"btn btn-default btn-xs ng-table-group-close\" ng-click=\"$groupRow.show=false; $event.preventDefault(); $event.stopPropagation();\"> <span class=\"glyphicon glyphicon-remove\"></span> </button> <button class=\"btn btn-default btn-xs ng-table-group-toggle\" ng-click=\"toggleDetail(); $event.preventDefault(); $event.stopPropagation();\"> <span class=\"glyphicon\" ng-class=\"{ \\'glyphicon-resize-small\\': params.settings().groupOptions.isExpanded, \\'glyphicon-resize-full\\': !params.settings().groupOptions.isExpanded }\"></span> </button> </a> <div class=\"list-group\" ng-if=\"isSelectorOpen\"> <a href=\"\" class=\"list-group-item\" ng-repeat=\"group in getGroupables()\" ng-click=\"groupBy(group)\"> <strong>{{ getGroupTitle(group)}}</strong> <strong ng-class=\"isSelectedGroup(group) && \\'sort-indicator\\'\"></strong> </a> </div> </th> </tr> ');\n\t\t$templateCache.put('ng-table/header.html', '<ng-table-group-row></ng-table-group-row> <ng-table-sorter-row></ng-table-sorter-row> <ng-table-filter-row></ng-table-filter-row> ');\n\t\t$templateCache.put('ng-table/pager.html', '<div class=\"ng-cloak ng-table-pager\" ng-if=\"params.data.length\"> <div ng-if=\"params.settings().counts.length\" class=\"ng-table-counts btn-group pull-right\"> <button ng-repeat=\"count in params.settings().counts\" type=\"button\" ng-class=\"{\\'active\\':params.count()==count}\" ng-click=\"params.count(count)\" class=\"btn btn-default\"> <span ng-bind=\"count\"></span> </button> </div> <ul ng-if=\"pages.length\" class=\"pagination ng-table-pagination\"> <li ng-class=\"{\\'disabled\\': !page.active && !page.current, \\'active\\': page.current}\" ng-repeat=\"page in pages\" ng-switch=\"page.type\"> <a ng-switch-when=\"prev\" ng-click=\"params.page(page.number)\" href=\"\">&laquo;</a> <a ng-switch-when=\"first\" ng-click=\"params.page(page.number)\" href=\"\"><span ng-bind=\"page.number\"></span></a> <a ng-switch-when=\"page\" ng-click=\"params.page(page.number)\" href=\"\"><span ng-bind=\"page.number\"></span></a> <a ng-switch-when=\"more\" ng-click=\"params.page(page.number)\" href=\"\">&#8230;</a> <a ng-switch-when=\"last\" ng-click=\"params.page(page.number)\" href=\"\"><span ng-bind=\"page.number\"></span></a> <a ng-switch-when=\"next\" ng-click=\"params.page(page.number)\" href=\"\">&raquo;</a> </li> </ul> </div> ');\n\t\t$templateCache.put('ng-table/sorterRow.html', '<tr class=\"ng-table-sort-header\"> <th title=\"{{$column.headerTitle(this)}}\" ng-repeat=\"$column in $columns\" ng-class=\"{ \\'sortable\\': $column.sortable(this), \\'sort-asc\\': params.sorting()[$column.sortable(this)]==\\'asc\\', \\'sort-desc\\': params.sorting()[$column.sortable(this)]==\\'desc\\' }\" ng-click=\"sortBy($column, $event)\" ng-if=\"$column.show(this)\" ng-init=\"template=$column.headerTemplateURL(this)\" class=\"header {{$column.class(this)}}\"> <div ng-if=\"!template\" class=\"ng-table-header\" ng-class=\"{\\'sort-indicator\\': params.settings().sortingIndicator==\\'div\\'}\"> <span ng-bind=\"$column.title(this)\" ng-class=\"{\\'sort-indicator\\': params.settings().sortingIndicator==\\'span\\'}\"></span> </div> <div ng-if=\"template\" ng-include=\"template\"></div> </th> </tr> ');\n\t}]);\n\t    return angular.module('ngTable');\n\t}));\n\n\n/***/ }\n\n});\n\n\n// WEBPACK FOOTER //\n// table.min.js","import tableComponent from './table.component';\nimport ffanTable from 'ffan-ng-table';\n\nexport default angular.module('tableDemo', [\n\t\tffanTable.name\n\t])\n\t/**\n\t * 轻在routerConfig.js里定义路由\n\t */\n\t.component('tableDemo', tableComponent);\n\t\t\t\t\t\t\t\t\n\n\n// WEBPACK FOOTER //\n// ./client/app/components/table/table.js","import template from './table.html';\nimport controller from './table.controller';\nimport './table.less';\n\nexport default {\n  restrict: 'E',\n  bindings: {},\n  template,\n  controller,\n  controllerAs: 'vm'\n};\n\n\n\n// WEBPACK FOOTER //\n// ./client/app/components/table/table.component.js","module.exports = \"<section class=\\\"intro-content\\\">\\n\\t<h1>表格</h1>\\n\\t<p>用于展示多条结构类似的数据，可对数据进行排序、筛选、对比或其他自定义操作。</p>\\n\\t<h2>安装</h2>\\n\\t<p>安装 ffan-ng-table</p>\\n</section>\\n\\n<div class=\\\"example-block\\\">\\n\\t<div class=\\\"highlight no-border\\\" hljs hljs-language=\\\"bash\\\">npm install ffan-ng-table --save</div>\\n</div>\\n\\n<section class=\\\"intro-content\\\">\\n\\t<h2>注入模块</h2>\\n\\t<p>在app.js或使用表格的模板入口js中注入 ffan-ng-table</p>\\n</section>\\n\\n<div class=\\\"example-block\\\">\\n<div class=\\\"highlight no-border\\\" hljs hljs-language=\\\"javascript\\\">\\nimport ffanTable from 'ffan-ng-table';\\n\\nangular.module('app', [\\n  ffanTable.name\\n])\\n.constant('$menuConstant', {\\n  DEBUG: process.env.DEBUG\\n})\\n.component('app', AppComponent);\\n</div>\\n</div>\\n\\n<section class=\\\"intro-content\\\">\\n\\t<h2>示例</h2>\\n</section>\\n\\n<div class=\\\"table-container\\\">\\n\\t<div class=\\\"table-wrapper ng-scope ng-table\\\">\\n\\t\\t<table class=\\\"table table-bordered table-hover\\\" ng-table=\\\"vm.tableParams\\\">\\n\\t\\t\\t<thead>\\n\\t\\t\\t<tr>\\n\\t\\t\\t\\t<th style=\\\"width: 25%;\\\">名称</th>\\n\\t\\t\\t\\t<th style=\\\"width: 15%;\\\">视图名称</th>\\n\\t\\t\\t\\t<th style=\\\"width: 20%;\\\">上一次编译结果的状态</th>\\n\\t\\t\\t\\t<th style=\\\"width: 20%;\\\">上一次编译结果的序号</th>\\n\\t\\t\\t\\t<th style=\\\"width: 20%;\\\">上一次编译失败的序号</th>\\n\\t\\t\\t</tr>\\n\\t\\t\\t</thead>\\n\\t\\t\\t<tbody ng-if=\\\"vm.tableParams.data.length != 0\\\">\\n\\t\\t\\t<tr ng-repeat=\\\"row in $data\\\">\\n\\t\\t\\t\\t<td>{{row.name}}</td>\\n\\t\\t\\t\\t<td>{{row.viewName}}</td>\\n\\t\\t\\t\\t<td>{{row.lastStatus}}</td>\\n\\t\\t\\t\\t<td>{{row.lastNO}}</td>\\n\\t\\t\\t\\t<td>{{row.lastFailNO}}</td>\\n\\t\\t\\t</tr>\\n\\t\\t\\t</tbody>\\n\\t\\t</table>\\n\\n\\t\\t<div class=\\\"prompt\\\" ng-if=\\\"vm.tableParams.data.length != 0\\\">\\n\\t\\t\\t<p class=\\\"text-danger\\\">点击存储卷名称可对其进行文件导入，导出操作.</p>\\n\\t\\t</div>\\n\\t\\t<div class=\\\"no-result\\\" ng-if=\\\"vm.tableParams.data.length == 0\\\">结果为空</div>\\n\\t</div>\\n</div>\\n\\n<div class=\\\"example-block\\\"  style=\\\"margin-top: 30px\\\">\\n\\t<div class=\\\"bs-example\\\">\\n\\t\\tview代码\\n\\t</div>\\n<div class=\\\"highlight\\\" hljs hljs-language=\\\"html\\\">\\n<div class=\\\"table-container\\\">\\n  <div class=\\\"table-wrapper ng-scope ng-table\\\">\\n\\t<table class=\\\"table table-bordered table-hover\\\" ng-table=\\\"vm.tableParams\\\">\\n\\t  <thead>\\n\\t\\t<tr>\\n\\t\\t  <th style=\\\"width: 25%;\\\">名称</th>\\n\\t\\t  <th style=\\\"width: 15%;\\\">视图名称</th>\\n\\t\\t  <th style=\\\"width: 20%;\\\">上一次编译结果的状态</th>\\n\\t\\t  <th style=\\\"width: 20%;\\\">上一次编译结果的序号</th>\\n\\t\\t  <th style=\\\"width: 20%;\\\">上一次编译失败的序号</th>\\n\\t\\t</tr>\\n\\t  </thead>\\n\\t  <tbody ng-if=\\\"vm.tableParams.data.length != 0\\\">\\n\\t    <tr ng-repeat=\\\"row in $data\\\">\\n\\t\\t  <td>{{row.name}}</td>\\n\\t\\t  <td>{{row.viewName}}</td>\\n\\t\\t  <td>{{row.lastStatus}}</td>\\n\\t\\t  <td>{{row.lastNO}}</td>\\n\\t\\t  <td>{{row.lastFailNO}}</td>\\n\\t    </tr>\\n\\t  </tbody>\\n\\t</table>\\n\\t<div class=\\\"prompt\\\" ng-if=\\\"vm.tableParams.data.length != 0\\\">\\n\\t  <p class=\\\"text-warning\\\">点击存储卷名称可对其进行文件导入，导出操作.</p>\\n\\t</div>\\n\\t<div class=\\\"no-result\\\" ng-if=\\\"vm.tableParams.data.length == 0\\\">结果为空</div>\\n  </div>\\n</div>\\n</div>\\n</div>\\n\\n\\n<div class=\\\"example-block\\\" style=\\\"margin-top: 30px\\\">\\n\\t<div class=\\\"bs-example\\\">\\n\\t\\tcontroller代码\\n\\t</div>\\n<div class=\\\"highlight\\\" hljs hljs-language=\\\"javascript\\\">\\nconstructor(NgTableParams) {\\n  \\\"ngInject\\\";\\n  this.NgTableParams = NgTableParams;\\n  this.init();\\n}\\n\\ninit(){\\n  var self = this;\\n    self.tableParams = new this.NgTableParams({\\n      page: 1,\\n      count: 5\\n    }, {\\n    counts: [],\\n      getData: function (params) {\\n      // call service to get table data\\n      params.total(self.data.total);\\n      return self.data && self.data.datas;\\n    }\\n  });\\n}\\n</div>\\n</div>\"\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./client/app/components/table/table.html\n// module id = 393\n// module chunks = 4","/**\n * (description)\n *\n * @author yourname\n */\n\nexport default class TableController {\n\tconstructor(NgTableParams) {\n\t\t\"ngInject\";\n\t\tthis.NgTableParams = NgTableParams;\n\t\tthis.data = {\n\t\t\t\"total\": 85,\n\t\t\t\"datas\": [\n\t\t\t\t{\n\t\t\t\t\t\"name\": 'fix_web',\n\t\t\t\t\t\"viewName\": \"tool-wd\",\n\t\t\t\t\t\"lastStatus\": \"SUCCESS\",\n\t\t\t\t\t\"lastNO\": \"#10\",\n\t\t\t\t\t\"lastFailNO\": \"#4\"\n\t\t\t\t},\n\t\t\t\t{\n\t\t\t\t\t\"name\": 'fix_web',\n\t\t\t\t\t\"viewName\": \"tool-wd\",\n\t\t\t\t\t\"lastStatus\": \"SUCCESS\",\n\t\t\t\t\t\"lastNO\": \"#10\",\n\t\t\t\t\t\"lastFailNO\": \"#4\"\n\t\t\t\t},\n\t\t\t\t{\n\t\t\t\t\t\"name\": 'fix_web',\n\t\t\t\t\t\"viewName\": \"tool-wd\",\n\t\t\t\t\t\"lastStatus\": \"SUCCESS\",\n\t\t\t\t\t\"lastNO\": \"#10\",\n\t\t\t\t\t\"lastFailNO\": \"#4\"\n\t\t\t\t},\n\t\t\t\t{\n\t\t\t\t\t\"name\": 'fix_web',\n\t\t\t\t\t\"viewName\": \"tool-wd\",\n\t\t\t\t\t\"lastStatus\": \"SUCCESS\",\n\t\t\t\t\t\"lastNO\": \"#10\",\n\t\t\t\t\t\"lastFailNO\": \"#4\"\n\t\t\t\t},\n\t\t\t\t{\n\t\t\t\t\t\"name\": 'fix_web',\n\t\t\t\t\t\"viewName\": \"tool-wd\",\n\t\t\t\t\t\"lastStatus\": \"SUCCESS\",\n\t\t\t\t\t\"lastNO\": \"#10\",\n\t\t\t\t\t\"lastFailNO\": \"#4\"\n\t\t\t\t}\n\t\t\t]\n\t\t};\n\t\tthis.init();\n\t}\n\n\tinit() {\n\t\tthis.getDataList();\n\t}\n\n\tgetDataList() {\n\t\tvar self = this;\n\t\tself.tableParams = new this.NgTableParams({\n\t\t\tpage: 1,\n\t\t\tcount: 5\n\t\t}, {\n\t\t\tcounts: [],\n\t\t\tgetData: function (params) {\n\t\t\t\t// call service to get table data\n\t\t\t\tparams.total(self.data.total);\n\t\t\t\treturn self.data && self.data.datas;\n\t\t\t}\n\t\t});\n\t}\n}\n\n\n// WEBPACK FOOTER //\n// ./client/app/components/table/table.controller.js","// style-loader: Adds some css to the DOM by adding a <style> tag\n\n// load the styles\nvar content = require(\"!!./../../../../node_modules/css-loader/index.js!./../../../../node_modules/less-loader/index.js!./table.less\");\nif(typeof content === 'string') content = [[module.id, content, '']];\n// add the styles to the DOM\nvar update = require(\"!./../../../../node_modules/style-loader/addStyles.js\")(content, {});\nif(content.locals) module.exports = content.locals;\n// Hot Module Replacement\nif(module.hot) {\n\t// When the styles change, update the <style> tags\n\tif(!content.locals) {\n\t\tmodule.hot.accept(\"!!./../../../../node_modules/css-loader/index.js!./../../../../node_modules/less-loader/index.js!./table.less\", function() {\n\t\t\tvar newContent = require(\"!!./../../../../node_modules/css-loader/index.js!./../../../../node_modules/less-loader/index.js!./table.less\");\n\t\t\tif(typeof newContent === 'string') newContent = [[module.id, newContent, '']];\n\t\t\tupdate(newContent);\n\t\t});\n\t}\n\t// When the module is disposed, remove the <style> tags\n\tmodule.hot.dispose(function() { update(); });\n}\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./client/app/components/table/table.less\n// module id = 395\n// module chunks = 4","exports = module.exports = require(\"./../../../../node_modules/css-loader/lib/css-base.js\")();\n// imports\n\n\n// module\nexports.push([module.id, \"\", \"\"]);\n\n// exports\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/css-loader!./~/less-loader!./client/app/components/table/table.less\n// module id = 396\n// module chunks = 4","(function(angular, factory) {\n    'use strict';\n\n    if (typeof define === 'function' && define.amd) {\n        define(['angular'], function(angular) {\n            return factory(angular);\n        });\n    } else {\n        return factory(angular);\n    }\n}(window.angular || null, function(angular) {\n    'use strict';\n\n/**\n * ngTable: Table + Angular JS\n *\n * @author Vitalii Savchuk <esvit666@gmail.com>\n * @url https://github.com/esvit/ng-table/\n * @license New BSD License <http://creativecommons.org/licenses/BSD/>\n */\n\n(function(){\n    /**\n     * @ngdoc module\n     * @name ngTable\n     * @description ngTable: Table + Angular JS\n     */\n    angular.module('ngTable', []);\n})();\n\n/**\n * ngTable: Table + Angular JS\n *\n * @author Vitalii Savchuk <esvit666@gmail.com>\n * @url https://github.com/esvit/ng-table/\n * @license New BSD License <http://creativecommons.org/licenses/BSD/>\n */\n\n(function () {\n    /**\n     * @ngdoc object\n     * @name ngTableDefaultParams\n     * @module ngTable\n     * @description Default Parameters for ngTable\n     */\n    angular.module('ngTable')\n        .value('ngTableDefaults', {\n            params: {},\n            settings: {}\n        });\n})();\n\n/**\n * ngTable: Table + Angular JS\n *\n * @author Vitalii Savchuk <esvit666@gmail.com>\n * @url https://github.com/esvit/ng-table/\n * @license New BSD License <http://creativecommons.org/licenses/BSD/>\n */\n\n(function(){\n    'use strict';\n\n    angular.module('ngTable')\n        .factory('ngTableEventsChannel', ngTableEventsChannel);\n\n    ngTableEventsChannel.$inject = ['$rootScope'];\n\n    /**\n     * @ngdoc service\n     * @name ngTableEventsChannel\n     * @description strongly typed pub/sub for `NgTableParams`\n     *\n     * Supported events:\n     *\n     * * afterCreated - raised when a new instance of `NgTableParams` has finished being constructed\n     * * afterReloadData - raised when the `reload` event has finished loading new data\n     * * datasetChanged - raised when `settings` receives a new data array\n     * * pagesChanged - raised when a new pages array has been generated\n     */\n    function ngTableEventsChannel($rootScope){\n\n        var events = {};\n        events = addChangeEvent('afterCreated', events);\n        events = addChangeEvent('afterReloadData', events);\n        events = addChangeEvent('datasetChanged', events);\n        events = addChangeEvent('pagesChanged', events);\n        return events;\n\n        //////////\n\n        function addChangeEvent(eventName, target){\n            var fnName = eventName.charAt(0).toUpperCase() + eventName.substring(1);\n            var event = {};\n            event['on' + fnName] = createEventSubscriptionFn(eventName);\n            event['publish' + fnName] = createPublishEventFn(eventName);\n            return angular.extend(target, event);\n        }\n\n        function createEventSubscriptionFn(eventName){\n\n            return function subscription(handler/*[, eventSelector or $scope][, eventSelector]*/){\n                var eventSelector = angular.identity;\n                var scope = $rootScope;\n\n                if (arguments.length === 2){\n                    if (angular.isFunction(arguments[1].$new)) {\n                        scope = arguments[1];\n                    } else {\n                        eventSelector = arguments[1]\n                    }\n                } else if (arguments.length > 2){\n                    scope = arguments[1];\n                    eventSelector = arguments[2];\n                }\n\n                // shorthand for subscriber to only receive events from a specific publisher instance\n                if (angular.isObject(eventSelector)) {\n                    var requiredPublisher = eventSelector;\n                    eventSelector = function(publisher){\n                        return publisher === requiredPublisher;\n                    }\n                }\n\n                return scope.$on('ngTable:' + eventName, function(event, params/*, ...args*/){\n                    // don't send events published by the internal NgTableParams created by ngTableController\n                    if (params.isNullInstance) return;\n\n                    var eventArgs = rest(arguments, 2);\n                    var fnArgs = [params].concat(eventArgs);\n                    if (eventSelector.apply(this, fnArgs)){\n                        handler.apply(this, fnArgs);\n                    }\n                });\n            }\n        }\n\n        function createPublishEventFn(eventName){\n            return function publish(/*args*/){\n                var fnArgs = ['ngTable:' + eventName].concat(Array.prototype.slice.call(arguments));\n                $rootScope.$broadcast.apply($rootScope, fnArgs);\n            }\n        }\n\n        function rest(array, n) {\n            return Array.prototype.slice.call(array, n == null ? 1 : n);\n        }\n    }\n})();\n\n/**\n * ngTable: Table + Angular JS\n *\n * @author Vitalii Savchuk <esvit666@gmail.com>\n * @url https://github.com/esvit/ng-table/\n * @license New BSD License <http://creativecommons.org/licenses/BSD/>\n */\n\n(function(){\n    'use strict';\n\n    angular.module('ngTable')\n        .provider('ngTableFilterConfig', ngTableFilterConfigProvider);\n\n    ngTableFilterConfigProvider.$inject = [];\n\n    function ngTableFilterConfigProvider(){\n        var config;\n        var defaultConfig = {\n            defaultBaseUrl: 'ng-table/filters/',\n            defaultExt: '.html',\n            aliasUrls: {}\n        };\n\n        this.$get = ngTableFilterConfig;\n        this.resetConfigs = resetConfigs;\n        this.setConfig = setConfig;\n\n        init();\n\n        /////////\n\n        function init(){\n            resetConfigs();\n        }\n\n        function resetConfigs(){\n            config = defaultConfig;\n        }\n\n        function setConfig(customConfig){\n            var mergeConfig = angular.extend({}, config, customConfig);\n            mergeConfig.aliasUrls = angular.extend({}, config.aliasUrls, customConfig.aliasUrls);\n            config = mergeConfig;\n        }\n\n        /////////\n\n        ngTableFilterConfig.$inject = [];\n\n        function ngTableFilterConfig(){\n\n            var publicConfig;\n\n            var service = {\n                config: publicConfig,\n                getTemplateUrl: getTemplateUrl,\n                getUrlForAlias: getUrlForAlias\n            };\n            Object.defineProperty(service, \"config\", {\n                get: function(){\n                    return publicConfig = publicConfig || angular.copy(config);\n                },\n                enumerable: true\n            });\n\n            return service;\n\n            /////////\n\n            function getTemplateUrl(filterValue, filterKey){\n                if (angular.isObject(filterValue)){\n                    filterValue = filterValue.id;\n                }\n                if (filterValue.indexOf('/') !== -1){\n                    return filterValue;\n                }\n\n                return service.getUrlForAlias(filterValue, filterKey);\n            }\n\n            function getUrlForAlias(aliasName/*, filterKey*/){\n                return config.aliasUrls[aliasName] || config.defaultBaseUrl + aliasName + config.defaultExt;\n            }\n        }\n    }\n})();\n\n/**\n * ngTable: Table + Angular JS\n *\n * @author Vitalii Savchuk <esvit666@gmail.com>\n * @url https://github.com/esvit/ng-table/\n * @license New BSD License <http://creativecommons.org/licenses/BSD/>\n */\n\n(function(){\n    'use strict';\n\n\n    angular.module('ngTable')\n        .provider('ngTableDefaultGetData', ngTableDefaultGetDataProvider);\n\n    ngTableDefaultGetDataProvider.$inject = [];\n\n    /**\n     * @ngdoc provider\n     * @name ngTableDefaultGetDataProvider\n     * @description Allows for the configuration of the ngTableDefaultGetData service.\n     *\n     * Set filterFilterName to the name of a angular filter that knows how to apply the values returned by\n     * `NgTableParams.filter()` to restrict an array of data.\n     *\n     * Set sortingFilterName to the name of a angular filter that knows how to apply the values returned by\n     * `NgTableParams.orderBy()` to sort an array of data.\n     *\n     * Out of the box the `ngTableDefaultGetData` service will be configured to use the angular `filter` and `orderBy`\n     * filters respectively\n     */\n    function ngTableDefaultGetDataProvider(){\n        var provider = this;\n        provider.$get = ngTableDefaultGetData;\n        provider.filterFilterName = 'filter';\n        provider.sortingFilterName = 'orderBy';\n\n        ///////////\n\n        ngTableDefaultGetData.$inject = ['$filter'];\n\n        /**\n         * @ngdoc service\n         * @name ngTableDefaultGetData\n         * @description A default implementation of the getData function that will apply the `filter`, `orderBy` and\n         * paging values from the `NgTableParams` instance supplied to the data array supplied.\n         *\n         * The outcome will be to return the resulting array and to assign the total item count after filtering\n         * to the `total` of the `NgTableParams` instance supplied\n         */\n        function ngTableDefaultGetData($filter) {\n\n            var defaultDataOptions = {applyFilter: true, applySort: true, applyPaging: true};\n\n            getData.applyPaging = applyPaging;\n            getData.getFilterFn = getFilterFn;\n            getData.getOrderByFn = getOrderByFn;\n\n            return getData;\n\n            function getFilterFn(params) {\n                var filterOptions = params.settings().filterOptions;\n                if (angular.isFunction(filterOptions.filterFn)){\n                    return filterOptions.filterFn;\n                } else {\n                    return $filter(filterOptions.filterFilterName || provider.filterFilterName);\n                }\n            }\n\n            function getOrderByFn (/*params*/){\n                return $filter(provider.sortingFilterName);\n            }\n\n            function applyFilter(data, params) {\n                if (!params.hasFilter()) {\n                    return data;\n                }\n\n                var filter = params.filter(true);\n                var filterKeys = Object.keys(filter);\n                var parsedFilter = filterKeys.reduce(function(result, key){\n                    result = setPath(result, filter[key], key);\n                    return result;\n                }, {});\n                var filterFn = getFilterFn(params);\n                return filterFn.call(params, data, parsedFilter, params.settings().filterOptions.filterComparator);\n            }\n\n            function applyPaging(data, params) {\n                var pagedData = data.slice((params.page() - 1) * params.count(), params.page() * params.count());\n                params.total(data.length); // set total for recalc pagination\n                return pagedData;\n            }\n\n            function applySort(data, params) {\n                var orderBy = params.orderBy();\n                var orderByFn = getOrderByFn(params);\n                return orderBy.length ? orderByFn(data, orderBy) : data;\n            }\n\n            function getData(data, params) {\n                if (data == null){\n                    return [];\n                }\n\n                var options = angular.extend({}, defaultDataOptions, params.settings().dataOptions);\n\n                var fData = options.applyFilter ? applyFilter(data, params) : data;\n                var orderedData = options.applySort ? applySort(fData, params) : fData;\n                return options.applyPaging ? applyPaging(orderedData, params) : orderedData;\n            }\n\n            // Sets the value at any depth in a nested object based on the path\n            // note: adapted from: underscore-contrib#setPath\n            function setPath(obj, value, path) {\n                var keys     = path.split('.');\n                var ret      = obj;\n                var lastKey  = keys[keys.length -1];\n                var target   = ret;\n\n                var parentPathKeys = keys.slice(0, keys.length -1);\n                parentPathKeys.forEach(function(key) {\n                    if (!target.hasOwnProperty(key)) {\n                        target[key] = {};\n                    }\n                    target = target[key];\n                });\n\n                target[lastKey] = value;\n                return ret;\n            }\n        }\n    }\n})();\n\n/**\n * ngTable: Table + Angular JS\n *\n * @author Vitalii Savchuk <esvit666@gmail.com>\n * @url https://github.com/esvit/ng-table/\n * @license New BSD License <http://creativecommons.org/licenses/BSD/>\n */\n\n(function(){\n    'use strict';\n\n    // todo: remove shim after an acceptable depreciation period\n\n    angular.module('ngTable')\n        .factory('ngTableGetDataBcShim', ngTableGetDataBcShim);\n\n    ngTableGetDataBcShim.$inject = ['$q'];\n\n    function ngTableGetDataBcShim($q){\n\n        return createWrapper;\n\n        function createWrapper(getDataFn){\n            return function getDataShim(/*args*/){\n                var $defer = $q.defer();\n                var pData = getDataFn.apply(this, [$defer].concat(Array.prototype.slice.call(arguments)));\n                if (!pData) {\n                    // If getData resolved the $defer, and didn't promise us data,\n                    //   create a promise from the $defer. We need to return a promise.\n                    pData = $defer.promise;\n                }\n                return pData;\n            }\n        }\n    }\n})();\n\n/**\n * ngTable: Table + Angular JS\n *\n * @author Vitalii Savchuk <esvit666@gmail.com>\n * @url https://github.com/esvit/ng-table/\n * @license New BSD License <http://creativecommons.org/licenses/BSD/>\n */\n\n(function () {\n    /**\n     * @ngdoc service\n     * @name ngTableColumn\n     * @module ngTable\n     * @description\n     * Service to construct a $column definition used by {@link ngTable ngTable} directive\n     */\n    angular.module('ngTable').factory('ngTableColumn', [function () {\n\n        return {\n            buildColumn: buildColumn\n        };\n\n        //////////////\n\n        /**\n         * @ngdoc method\n         * @name ngTableColumn#buildColumn\n         * @description Creates a $column for use within a header template\n         *\n         * @param {Object} column an existing $column or simple column data object\n         * @param {Scope} defaultScope the $scope to supply to the $column getter methods when not supplied by caller\n         * @param {Array} columns a reference to the columns array to make available on the context supplied to the\n         * $column getter methods\n         * @returns {Object} a $column object\n         */\n        function buildColumn(column, defaultScope, columns){\n            // note: we're not modifying the original column object. This helps to avoid unintended side affects\n            var extendedCol = Object.create(column);\n            var defaults = createDefaults();\n            for (var prop in defaults) {\n                if (extendedCol[prop] === undefined) {\n                    extendedCol[prop] = defaults[prop];\n                }\n                if(!angular.isFunction(extendedCol[prop])){\n                    // wrap raw field values with \"getter\" functions\n                    // - this is to ensure consistency with how ngTable.compile builds columns\n                    // - note that the original column object is being \"proxied\"; this is important\n                    //   as it ensure that any changes to the original object will be returned by the \"getter\"\n                    (function(prop1){\n                        var getterSetter = function getterSetter(/*[value] || [$scope, locals]*/) {\n                            if (arguments.length === 1 && !isScopeLike(arguments[0])) {\n                                getterSetter.assign(null, arguments[0]);\n                            } else {\n                                return column[prop1];\n                            }\n                        };\n                        getterSetter.assign = function($scope, value){\n                            column[prop1] = value;\n                        };\n                        extendedCol[prop1] = getterSetter;\n                    })(prop);\n                }\n                (function(prop1){\n                    // satisfy the arguments expected by the function returned by parsedAttribute in the ngTable directive\n                    var getterFn = extendedCol[prop1];\n                    extendedCol[prop1] = function () {\n                        if (arguments.length === 1 && !isScopeLike(arguments[0])){\n                            getterFn.assign(null, arguments[0]);\n                        } else {\n                            var scope = arguments[0] || defaultScope;\n                            var context = Object.create(scope);\n                            angular.extend(context, {\n                                $column: extendedCol,\n                                $columns: columns\n                            });\n                            return getterFn.call(column, context);\n                        }\n                    };\n                    if (getterFn.assign){\n                        extendedCol[prop1].assign = getterFn.assign;\n                    }\n                })(prop);\n            }\n            return extendedCol;\n        }\n\n        function createDefaults(){\n            return {\n                'class': createGetterSetter(''),\n                filter: createGetterSetter(false),\n                groupable: createGetterSetter(false),\n                filterData: angular.noop,\n                headerTemplateURL: createGetterSetter(false),\n                headerTitle: createGetterSetter(''),\n                sortable: createGetterSetter(false),\n                show: createGetterSetter(true),\n                title: createGetterSetter(''),\n                titleAlt: createGetterSetter('')\n            };\n        }\n\n        function createGetterSetter(initialValue){\n            var value = initialValue;\n            var getterSetter = function getterSetter(/*[value] || [$scope, locals]*/){\n                if (arguments.length === 1 && !isScopeLike(arguments[0])) {\n                    getterSetter.assign(null, arguments[0]);\n                } else {\n                    return value;\n                }\n            };\n            getterSetter.assign = function($scope, newValue){\n                value = newValue;\n            };\n            return getterSetter;\n        }\n\n        function isScopeLike(object){\n            return object != null && angular.isFunction(object.$new);\n        }\n    }]);\n})();\n\n/**\n * ngTable: Table + Angular JS\n *\n * @author Vitalii Savchuk <esvit666@gmail.com>\n * @url https://github.com/esvit/ng-table/\n * @license New BSD License <http://creativecommons.org/licenses/BSD/>\n */\n\n(function(){\n    /**\n     * @ngdoc service\n     * @name NgTableParams\n     * @module ngTable\n     * @description Parameters manager for ngTable\n     */\n\n    angular.module('ngTable').factory('NgTableParams', ['$q', '$log', '$filter', 'ngTableDefaults', 'ngTableGetDataBcShim', 'ngTableDefaultGetData', 'ngTableEventsChannel', function($q, $log, $filter, ngTableDefaults, ngTableGetDataBcShim, ngTableDefaultGetData, ngTableEventsChannel) {\n        var isNumber = function(n) {\n            return !isNaN(parseFloat(n)) && isFinite(n);\n        };\n        var NgTableParams = function(baseParameters, baseSettings) {\n\n            // the ngTableController \"needs\" to create a dummy/null instance and it's important to know whether an instance\n            // is one of these\n            if (typeof baseParameters === \"boolean\"){\n                this.isNullInstance = true;\n            }\n\n            var self = this,\n                prevParamsMemento,\n                errParamsMemento,\n                isCommittedDataset = false,\n                initialEvents = [],\n                log = function() {\n                    if (settings.debugMode && $log.debug) {\n                        $log.debug.apply($log, arguments);\n                    }\n                },\n                defaultFilterOptions = {\n                    filterComparator: undefined, // look for a substring match in case insensitive way\n                    filterDelay: 500,\n                    filterDelayThreshold: 10000, // size of dataset array that will trigger the filterDelay being applied\n                    filterFilterName: undefined, // when defined overrides ngTableDefaultGetDataProvider.filterFilterName\n                    filterFn: undefined, // when defined overrides the filter function that ngTableDefaultGetData uses\n                    filterLayout: 'stack' // alternative: 'horizontal'\n                },\n                defaultGroupOptions = {\n                    defaultSort: 'asc', // set to 'asc' or 'desc' to apply sorting to groups\n                    isExpanded: true\n                },\n                defaultSettingsFns = getDefaultSettingFns();\n\n            this.data = [];\n\n            /**\n             * @ngdoc method\n             * @name NgTableParams#parameters\n             * @description Set new parameters or get current parameters\n             *\n             * @param {string} newParameters      New parameters\n             * @param {string} parseParamsFromUrl Flag if parse parameters like in url\n             * @returns {Object} Current parameters or `this`\n             */\n            this.parameters = function(newParameters, parseParamsFromUrl) {\n                parseParamsFromUrl = parseParamsFromUrl || false;\n                if (angular.isDefined(newParameters)) {\n                    for (var key in newParameters) {\n                        var value = newParameters[key];\n                        if (parseParamsFromUrl && key.indexOf('[') >= 0) {\n                            var keys = key.split(/\\[(.*)\\]/).reverse()\n                            var lastKey = '';\n                            for (var i = 0, len = keys.length; i < len; i++) {\n                                var name = keys[i];\n                                if (name !== '') {\n                                    var v = value;\n                                    value = {};\n                                    value[lastKey = name] = (isNumber(v) ? parseFloat(v) : v);\n                                }\n                            }\n                            if (lastKey === 'sorting') {\n                                params[lastKey] = {};\n                            }\n                            params[lastKey] = angular.extend(params[lastKey] || {}, value[lastKey]);\n                        } else {\n                            if (key === 'group'){\n                                params[key] = parseGroup(newParameters[key]);\n                            } else {\n                                params[key] = (isNumber(newParameters[key]) ? parseFloat(newParameters[key]) : newParameters[key]);\n                            }\n                        }\n                    }\n                    log('ngTable: set parameters', params);\n                    return this;\n                }\n                return params;\n            };\n\n            function parseGroup(group){\n                var defaultSort = settings.groupOptions && settings.groupOptions.defaultSort;\n                if (angular.isFunction(group)) {\n                    if (group.sortDirection == null){\n                        group.sortDirection = defaultSort;\n                    }\n                    return group;\n                } else if (angular.isString(group)) {\n                    var grp = {};\n                    grp[group] = defaultSort;\n                    return grp;\n                } else if (angular.isObject(group)) {\n                    for (var key in group) {\n                        if (group[key] == null){\n                            group[key] = defaultSort;\n                        }\n                    }\n                    return group;\n                } else {\n                    return group;\n                }\n            }\n\n            /**\n             * @ngdoc method\n             * @name NgTableParams#settings\n             * @description Set new settings for table\n             *\n             * @param {string} newSettings New settings or undefined\n             * @returns {Object} Current settings or `this`\n             */\n            this.settings = function(newSettings) {\n                if (angular.isDefined(newSettings)) {\n\n                    // todo: don't modify newSettings object: this introduces unexpected side effects;\n                    // instead take a copy of newSettings\n\n                    if (newSettings.filterOptions){\n                        newSettings.filterOptions = angular.extend({}, settings.filterOptions, newSettings.filterOptions);\n                    }\n                    if (newSettings.groupOptions){\n                        newSettings.groupOptions = angular.extend({}, settings.groupOptions, newSettings.groupOptions);\n                    }\n\n                    if (angular.isArray(newSettings.dataset)) {\n                        //auto-set the total from passed in dataset\n                        newSettings.total = newSettings.dataset.length;\n                    }\n\n                    // todo: remove the backwards compatibility shim and the following two if blocks\n                    if (newSettings.getData && newSettings.getData.length > 1){\n                        // support the old getData($defer, params) api\n                        newSettings.getDataFnAdaptor = ngTableGetDataBcShim;\n                    }\n                    if (newSettings.getGroups && newSettings.getGroups.length > 2){\n                        // support the old getGroups($defer, params) api\n                        newSettings.getGroupsFnAdaptor = ngTableGetDataBcShim;\n                    }\n\n                    var originalDataset = settings.dataset;\n                    settings = angular.extend(settings, newSettings);\n\n                    if (angular.isArray(newSettings.dataset)) {\n                        optimizeFilterDelay();\n                    }\n\n                    // note: using != as want null and undefined to be treated the same\n                    var hasDatasetChanged = newSettings.hasOwnProperty('dataset') && (newSettings.dataset != originalDataset);\n                    if (hasDatasetChanged) {\n                        if (isCommittedDataset){\n                            this.page(1); // reset page as a new dataset has been supplied\n                        }\n                        isCommittedDataset = false;\n\n                        var fireEvent = function () {\n                            ngTableEventsChannel.publishDatasetChanged(self, newSettings.dataset, originalDataset);\n                        };\n\n                        if (initialEvents){\n                            initialEvents.push(fireEvent);\n                        } else {\n                            fireEvent();\n                        }\n                    }\n                    log('ngTable: set settings', settings);\n                    return this;\n                }\n                return settings;\n            };\n\n            /**\n             * @ngdoc method\n             * @name NgTableParams#page\n             * @description If parameter page not set return current page else set current page\n             *\n             * @param {string} page Page number\n             * @returns {Object|Number} Current page or `this`\n             */\n            this.page = function(page) {\n                return angular.isDefined(page) ? this.parameters({\n                    'page': page\n                }) : params.page;\n            };\n\n            /**\n             * @ngdoc method\n             * @name NgTableParams#total\n             * @description If parameter total not set return current quantity else set quantity\n             *\n             * @param {string} total Total quantity of items\n             * @returns {Object|Number} Current page or `this`\n             */\n            this.total = function(total) {\n                return angular.isDefined(total) ? this.settings({\n                    'total': total\n                }) : settings.total;\n            };\n\n            /**\n             * @ngdoc method\n             * @name NgTableParams#count\n             * @description If parameter count not set return current count per page else set count per page\n             *\n             * @param {string} count Count per number\n             * @returns {Object|Number} Count per page or `this`\n             */\n            this.count = function(count) {\n                // reset to first page because can be blank page\n                return angular.isDefined(count) ? this.parameters({\n                    'count': count,\n                    'page': 1\n                }) : params.count;\n            };\n\n            /**\n             * @ngdoc method\n             * @name NgTableParams#filter\n             * @description If 'filter' parameter not set return current filter else set current filter\n             *\n             * Note: when assigning a new filter, {@link NgTableParams#page page} will be set to 1\n             *\n             * @param {Object|Boolean} filter 'object': new filter to assign or\n             * 'true': to return the current filter minus any insignificant values (null,  undefined and empty string); or\n             * 'falsey': to return the current filter \"as is\"\n             * @returns {Object} Current filter or `this`\n             */\n            this.filter = function(filter) {\n                if (angular.isDefined(filter) && angular.isObject(filter)) {\n                    return this.parameters({\n                        'filter': filter,\n                        'page': 1\n                    });\n                } else if (filter === true){\n                    var keys = Object.keys(params.filter);\n                    var significantFilter = {};\n                    for (var i=0; i < keys.length; i++){\n                        var filterValue = params.filter[keys[i]];\n                        if (filterValue != null && filterValue !== '') {\n                            significantFilter[keys[i]] = filterValue;\n                        }\n                    }\n                    return significantFilter;\n                } else {\n                    return params.filter;\n                }\n            };\n\n            /**\n             * @ngdoc method\n             * @name NgTableParams#group\n             * @description If 'group' parameter is not set, return current grouping. Otherwise set current group.\n             *\n             * @param {string|Function|Object} group New group field\n             * @param {string} sortDirection Optional direction that the list of groups should be sorted\n             * @returns {Object} Current grouping or `this`\n             */\n            this.group = function(group, sortDirection) {\n                if (!angular.isDefined(group)){\n                    return params.group;\n                }\n\n                var newParameters = {\n                    page: 1\n                };\n                if (angular.isFunction(group) && angular.isDefined(sortDirection)){\n                    group.sortDirection = sortDirection;\n                    newParameters.group = group;\n                } else if (angular.isDefined(group) && angular.isDefined(sortDirection)) {\n                    var groupArray = {};\n                    groupArray[group] = sortDirection;\n                    newParameters.group = groupArray;\n                } else {\n                    newParameters.group = group;\n                }\n                this.parameters(newParameters);\n                return this;\n            };\n\n            /**\n             * @ngdoc method\n             * @name NgTableParams#sorting\n             * @description If 'sorting' parameter is not set, return current sorting. Otherwise set current sorting.\n             *\n             * @param {string} sorting New sorting\n             * @returns {Object} Current sorting or `this`\n             */\n            this.sorting = function(sorting) {\n                if (arguments.length == 2) {\n                    var sortArray = {};\n                    sortArray[sorting] = arguments[1];\n                    this.parameters({\n                        'sorting': sortArray\n                    });\n                    return this;\n                }\n                return angular.isDefined(sorting) ? this.parameters({\n                    'sorting': sorting\n                }) : params.sorting;\n            };\n\n            /**\n             * @ngdoc method\n             * @name NgTableParams#isSortBy\n             * @description Checks sort field\n             *\n             * @param {string} field     Field name\n             * @param {string} direction Optional direction of sorting ('asc' or 'desc')\n             * @returns {Array} Return true if field sorted by direction\n             */\n            this.isSortBy = function(field, direction) {\n                if(direction !== undefined) {\n                    return angular.isDefined(params.sorting[field]) && params.sorting[field] == direction;\n                } else {\n                    return angular.isDefined(params.sorting[field]);\n                }\n            };\n\n            /**\n             * @ngdoc method\n             * @name NgTableParams#orderBy\n             * @description Return object of sorting parameters for angular filter\n             *\n             * @returns {Array} Array like: [ '-name', '+age' ]\n             */\n            this.orderBy = function() {\n                return convertSortToOrderBy(params.sorting);\n            };\n\n            function convertSortToOrderBy(sorting){\n                var result = [];\n                for (var column in sorting) {\n                    result.push((sorting[column] === \"asc\" ? \"+\" : \"-\") + column);\n                }\n                return result;\n            }\n\n            /**\n             * @ngdoc method\n             * @name NgTableParams#generatePagesArray\n             * @description Generate array of pages\n             *\n             * When no arguments supplied, the current parameter state of this `NgTableParams` instance will be used\n             *\n             * @param {boolean} currentPage which page must be active\n             * @param {boolean} totalItems  Total quantity of items\n             * @param {boolean} pageSize    Quantity of items on page\n             * @param {number} maxBlocks    Quantity of blocks for pagination\n             * @returns {Array} Array of pages\n             */\n            this.generatePagesArray = function(currentPage, totalItems, pageSize, maxBlocks) {\n                if (!arguments.length){\n                    currentPage = this.page();\n                    totalItems = this.total();\n                    pageSize = this.count();\n                }\n\n                var maxPage, maxPivotPages, minPage, numPages, pages;\n                maxBlocks = maxBlocks && maxBlocks < 6 ? 6 : maxBlocks;\n\n                pages = [];\n                numPages = Math.ceil(totalItems / pageSize);\n                if (numPages > 1) {\n                    pages.push({\n                        type: 'prev',\n                        number: Math.max(1, currentPage - 1),\n                        active: currentPage > 1\n                    });\n                    pages.push({\n                        type: 'first',\n                        number: 1,\n                        active: currentPage > 1,\n                        current: currentPage === 1\n                    });\n                    maxPivotPages = Math.round((settings.paginationMaxBlocks - settings.paginationMinBlocks) / 2);\n                    minPage = Math.max(2, currentPage - maxPivotPages);\n                    maxPage = Math.min(numPages - 1, currentPage + maxPivotPages * 2 - (currentPage - minPage));\n                    minPage = Math.max(2, minPage - (maxPivotPages * 2 - (maxPage - minPage)));\n                    var i = minPage;\n                    while (i <= maxPage) {\n                        if ((i === minPage && i !== 2) || (i === maxPage && i !== numPages - 1)) {\n                            pages.push({\n                                type: 'more',\n                                active: false\n                            });\n                        } else {\n                            pages.push({\n                                type: 'page',\n                                number: i,\n                                active: currentPage !== i,\n                                current: currentPage === i\n                            });\n                        }\n                        i++;\n                    }\n                    pages.push({\n                        type: 'last',\n                        number: numPages,\n                        active: currentPage !== numPages,\n                        current: currentPage === numPages\n                    });\n                    pages.push({\n                        type: 'next',\n                        number: Math.min(numPages, currentPage + 1),\n                        active: currentPage < numPages\n                    });\n                }\n                return pages;\n            };\n\n            /**\n             * @ngdoc method\n             * @name NgTableParams#isDataReloadRequired\n             * @description Return true when a change to this `NgTableParams` instance should require the reload method\n             * to be run so as to ensure the data presented to the user reflects the `NgTableParams`\n             *\n             * Note that this method will return false when the reload method has run but fails. In this case\n             * `hasErrorState` will return true.\n             */\n            this.isDataReloadRequired = function(){\n                // note: using != as want to treat null and undefined the same\n                return !isCommittedDataset || !angular.equals(createComparableParams(), prevParamsMemento)\n                    || hasGlobalSearchFieldChanges();\n            };\n\n            function createComparableParams(){\n                var result = {params: params};\n                if (angular.isFunction(params.group)){\n                    result.groupSortDirection = params.group.sortDirection;\n                }\n                return result\n            }\n            /**\n             * @ngdoc method\n             * @name NgTableParams#hasFilter\n             * @description Determines if NgTableParams#filter has significant filter value(s)\n             * (any value except null, undefined, or empty string)\n             * @returns {Boolean} true when NgTableParams#filter has at least one significant field value\n             */\n            this.hasFilter = function(){\n                return Object.keys(this.filter(true)).length > 0;\n            };\n\n            /**\n             * @ngdoc method\n             * @name NgTableParams#hasGroup\n             * @description Determines if at least one group has been set\n             * @returns {Boolean}\n             */\n            this.hasGroup = function(group, sortDirection){\n                if (group == null) {\n                    return angular.isFunction(params.group) || Object.keys(params.group).length > 0\n                }\n\n                if (angular.isFunction(group)) {\n                    if (sortDirection == null) {\n                        return params.group === group;\n                    } else {\n                        return params.group === group && group.sortDirection === sortDirection;\n                    }\n                } else {\n                    if (sortDirection == null) {\n                        return Object.keys(params.group).indexOf(group) !== -1;\n                    } else {\n                        return params.group[group] === sortDirection;\n                    }\n                }\n            };\n\n            /**\n             * @ngdoc method\n             * @name NgTableParams#hasFilterChanges\n             * @description Return true when a change to `NgTableParams.filters`require the reload method\n             * to be run so as to ensure the data presented to the user reflects these filters\n             */\n            this.hasFilterChanges = function(){\n                var previousFilter = (prevParamsMemento && prevParamsMemento.params.filter);\n                return !angular.equals((params.filter), previousFilter) || hasGlobalSearchFieldChanges();\n            };\n\n            function hasGlobalSearchFieldChanges(){\n                var currentVal = (params.filter && params.filter.$);\n                var previousVal =\n                    (prevParamsMemento && prevParamsMemento.params.filter && prevParamsMemento.params.filter.$);\n                return !angular.equals(currentVal, previousVal);\n            }\n\n            /**\n             * @ngdoc method\n             * @name NgTableParams#url\n             * @description Return groups for table grouping\n             *\n             * @param {boolean} asString flag indicates return array of string or object\n             * @returns {Array} If asString = true will be return array of url string parameters else key-value object\n             */\n            this.url = function(asString) {\n                asString = asString || false;\n                var pairs = (asString ? [] : {});\n                for (var key in params) {\n                    if (params.hasOwnProperty(key)) {\n                        var item = params[key],\n                            name = encodeURIComponent(key);\n                        if (typeof item === \"object\") {\n                            for (var subkey in item) {\n                                if (isSignificantValue(item[subkey], key)) {\n                                    var pname = name + \"[\" + encodeURIComponent(subkey) + \"]\";\n                                    collectValue(item[subkey], pname);\n                                }\n                            }\n                        } else if (!angular.isFunction(item) && isSignificantValue(item, key)) {\n                            collectValue(item, name);\n                        }\n                    }\n                }\n                return pairs;\n\n                function collectValue(value, key){\n                    if (asString) {\n                        pairs.push(key + \"=\" + encodeURIComponent(value));\n                    } else {\n                        pairs[key] = encodeURIComponent(value);\n                    }\n                }\n\n                function isSignificantValue(value, key){\n                    return key === \"group\" ? true : angular.isDefined(value) && value !== \"\";\n                }\n            };\n\n            /**\n             * @ngdoc method\n             * @name NgTableParams#reload\n             * @description Reload table data\n             */\n            this.reload = function() {\n                var self = this,\n                    pData = null;\n\n                settings.$loading = true;\n\n                prevParamsMemento = angular.copy(createComparableParams());\n                isCommittedDataset = true;\n\n                if (self.hasGroup()) {\n                    pData = runInterceptorPipeline(runGetGroups);\n                } else {\n                    pData = runInterceptorPipeline(runGetData);\n                }\n\n                log('ngTable: reload data');\n\n                var oldData = self.data;\n                return pData.then(function(data) {\n                    settings.$loading = false;\n                    errParamsMemento = null;\n\n                    self.data = data;\n                    // note: I think it makes sense to publish this event even when data === oldData\n                    // subscribers can always set a filter to only receive the event when data !== oldData\n                    ngTableEventsChannel.publishAfterReloadData(self, data, oldData);\n                    self.reloadPages();\n\n                    // todo: remove after acceptable depreciation period\n                    if (settings.$scope) {\n                        settings.$scope.$emit('ngTableAfterReloadData');\n                    }\n\n                    return data;\n                }).catch(function(reason){\n                    errParamsMemento = prevParamsMemento;\n                    // \"rethrow\"\n                    return $q.reject(reason);\n                });\n            };\n\n            /**\n             * @ngdoc method\n             * @name NgTableParams#hasErrorState\n             * @description Return true when an attempt to `reload` the current `parameter` values have resulted in\n             * a failure\n             *\n             * This method will continue to return true until the reload is successfully called or when the\n             * `parameter` values have changed\n             */\n            this.hasErrorState = function(){\n                return !!(errParamsMemento && angular.equals(errParamsMemento, createComparableParams()));\n            };\n\n            function optimizeFilterDelay(){\n                // don't debounce by default filter input when working with small synchronous datasets\n                if (settings.filterOptions.filterDelay === defaultFilterOptions.filterDelay &&\n                    settings.total <= settings.filterOptions.filterDelayThreshold &&\n                    settings.getData === defaultSettingsFns.getData){\n                    settings.filterOptions.filterDelay = 0;\n                }\n            }\n\n            this.reloadPages = (function() {\n                var currentPages;\n                return function(){\n                    var oldPages = currentPages;\n                    var newPages = self.generatePagesArray(self.page(), self.total(), self.count());\n                    if (!angular.equals(oldPages, newPages)){\n                        currentPages = newPages;\n                        ngTableEventsChannel.publishPagesChanged(this, newPages, oldPages);\n                    }\n                }\n            })();\n\n            function runGetData(){\n                var getDataFn = settings.getDataFnAdaptor(settings.getData);\n                return $q.when(getDataFn.call(settings, self));\n            }\n\n            function runGetGroups(){\n                var getGroupsFn = settings.getGroupsFnAdaptor(settings.getGroups);\n                return $q.when(getGroupsFn.call(settings, self));\n            }\n\n            function runInterceptorPipeline(fetchFn){\n                var interceptors = settings.interceptors || [];\n\n                return interceptors.reduce(function(result, interceptor){\n                    var thenFn = (interceptor.response && interceptor.response.bind(interceptor)) || $q.when;\n                    var rejectFn = (interceptor.responseError && interceptor.responseError.bind(interceptor)) || $q.reject;\n                    return result.then(function(data){\n                        return thenFn(data, self);\n                    }, function(reason){\n                        return rejectFn(reason, self);\n                    });\n                }, fetchFn());\n            }\n\n            function getDefaultSettingFns(){\n\n                return {\n                    getDataFnAdaptor: angular.identity,\n                    getGroupsFnAdaptor: angular.identity,\n                    getData: getData,\n                    getGroups: getGroups\n                };\n\n                /**\n                 * @ngdoc method\n                 * @name settings#getData\n                 * @description Returns the data to display in the table\n                 *\n                 * Called by `NgTableParams` whenever it considers new data is to be loaded\n                 *\n                 * @param {Object} params the `NgTableParams` requesting data\n                 */\n                function getData(params) {\n                    return ngTableDefaultGetData(params.settings().dataset, params);\n                }\n\n                /**\n                 * @ngdoc method\n                 * @name settings#getGroups\n                 * @description Return groups of data to display in the table\n                 *\n                 * Called by `NgTableParams` whenever it considers new data is to be loaded\n                 * and when a `group` value has been assigned\n                 *\n                 * @param {Object} params the `NgTableParams` requesting data\n                 */\n                function getGroups(params) {\n\n                    var group = params.group();\n                    var groupFn;\n                    var sortDirection = undefined;\n                    if (angular.isFunction(group)) {\n                        groupFn = group;\n                        sortDirection = group.sortDirection;\n                    } else {\n                        // currently support for only one group implemented\n                        var groupField = Object.keys(group)[0];\n                        sortDirection = group[groupField];\n                        groupFn = function(item){\n                            return getPath(item, groupField);\n                        };\n                    }\n\n                    var settings = params.settings();\n                    var originalDataOptions = settings.dataOptions;\n                    settings.dataOptions = { applyPaging: false };\n                    var adaptedFn = settings.getDataFnAdaptor(settings.getData);\n                    var gotData = $q.when(adaptedFn.call(settings, params));\n                    return gotData.then(function(data) {\n                        var groups = {};\n                        angular.forEach(data, function(item) {\n                            var groupName = groupFn(item);\n                            groups[groupName] = groups[groupName] || {\n                                    data: [],\n                                    $hideRows: !settings.groupOptions.isExpanded,\n                                    value: groupName\n                                };\n                            groups[groupName].data.push(item);\n                        });\n                        var result = [];\n                        for (var i in groups) {\n                            result.push(groups[i]);\n                        }\n                        if (sortDirection) {\n                            var orderByFn = ngTableDefaultGetData.getOrderByFn();\n                            var orderBy = convertSortToOrderBy({\n                                value: sortDirection\n                            });\n                            result = orderByFn(result, orderBy);\n                        }\n\n                        return ngTableDefaultGetData.applyPaging(result, params);\n                    }).finally(function(){\n                        // restore the real options\n                        settings.dataOptions = originalDataOptions;\n                    });\n                }\n\n                function getPath (obj, ks) {\n                    // origianl source https://github.com/documentcloud/underscore-contrib\n\n                    if (typeof ks == \"string\") ks = ks.split(\".\");\n\n                    // If we have reached an undefined property\n                    // then stop executing and return undefined\n                    if (obj === undefined) return void 0;\n\n                    // If the path array has no more elements, we've reached\n                    // the intended property and return its value\n                    if (ks.length === 0) return obj;\n\n                    // If we still have elements in the path array and the current\n                    // value is null, stop executing and return undefined\n                    if (obj === null) return void 0;\n\n                    return getPath(obj[ks[0]], ks.slice(1));\n                }\n            }\n\n            var params = {\n                page: 1,\n                count: 10,\n                filter: {},\n                sorting: {},\n                group: {}\n            };\n            angular.extend(params, ngTableDefaults.params);\n\n            /**\n             * @ngdoc object\n             * @name settings\n             * @module ngTable\n             * @description configuration settings for `NgTableParams`\n             */\n            var settings = {\n                // todo: remove $scope after acceptable depreciation period as no longer required\n                $scope: null, // set by ngTable controller\n                $loading: false,\n                dataset: null, //allows data to be set when table is initialized\n                total: 0,\n                defaultSort: 'desc',\n                filterOptions: angular.copy(defaultFilterOptions),\n                groupOptions: angular.copy(defaultGroupOptions),\n                counts: [10, 25, 50, 100],\n                interceptors: [],\n                paginationMaxBlocks: 11,\n                paginationMinBlocks: 5,\n                sortingIndicator: 'span'\n            };\n\n            this.settings(defaultSettingsFns);\n            this.settings(ngTableDefaults.settings);\n            this.settings(baseSettings);\n            this.parameters(baseParameters, true);\n\n            ngTableEventsChannel.publishAfterCreated(this);\n            // run events during construction after the initial create event. That way a consumer\n            // can subscribe to all events for a table without \"dropping\" an event\n            angular.forEach(initialEvents, function(event){\n                event();\n            });\n            initialEvents = null;\n\n            return this;\n        };\n        return NgTableParams;\n    }]);\n\n    /**\n     * @ngdoc service\n     * @name ngTableParams\n     * @description Backwards compatible shim for lowercase 'n' in NgTableParams\n     */\n    angular.module('ngTable').factory('ngTableParams', ['NgTableParams', function(NgTableParams) {\n        return NgTableParams;\n    }]);\n})();\n\n\n\n/**\n * ngTable: Table + Angular JS\n *\n * @author Vitalii Savchuk <esvit666@gmail.com>\n * @url https://github.com/esvit/ng-table/\n * @license New BSD License <http://creativecommons.org/licenses/BSD/>\n */\n\n(function(){\n    /**\n     * @ngdoc object\n     * @name ngTableController\n     *\n     * @description\n     * Each {@link ngTable ngTable} directive creates an instance of `ngTableController`\n     */\n    angular.module('ngTable').controller('ngTableController', ['$scope', 'NgTableParams', '$timeout', '$parse', '$compile', '$attrs', '$element',\n        'ngTableColumn', 'ngTableEventsChannel',\n        function($scope, NgTableParams, $timeout, $parse, $compile, $attrs, $element, ngTableColumn, ngTableEventsChannel) {\n            var isFirstTimeLoad = true;\n            $scope.$filterRow = {};\n            $scope.$loading = false;\n\n            // until such times as the directive uses an isolated scope, we need to ensure that the check for\n            // the params field only consults the \"own properties\" of the $scope. This is to avoid seeing the params\n            // field on a $scope higher up in the prototype chain\n            if (!$scope.hasOwnProperty(\"params\")) {\n                $scope.params = new NgTableParams(true);\n            }\n            $scope.params.settings().$scope = $scope;\n\n            var delayFilter = (function() {\n                var timer = 0;\n                return function(callback, ms) {\n                    $timeout.cancel(timer);\n                    timer = $timeout(callback, ms);\n                };\n            })();\n\n            function onDataReloadStatusChange (newStatus/*, oldStatus*/) {\n                if (!newStatus || $scope.params.hasErrorState()) {\n                    return;\n                }\n\n                $scope.params.settings().$scope = $scope;\n\n                var currentParams = $scope.params;\n                var filterOptions = currentParams.settings().filterOptions;\n\n                if (currentParams.hasFilterChanges()) {\n                    var applyFilter = function () {\n                        currentParams.page(1);\n                        currentParams.reload();\n                    };\n                    if (filterOptions.filterDelay) {\n                        delayFilter(applyFilter, filterOptions.filterDelay);\n                    } else {\n                        applyFilter();\n                    }\n                } else {\n                    currentParams.reload();\n                }\n            }\n\n            // watch for when a new NgTableParams is bound to the scope\n            // CRITICAL: the watch must be for reference and NOT value equality; this is because NgTableParams maintains\n            // the current data page as a field. Checking this for value equality would be terrible for performance\n            // and potentially cause an error if the items in that array has circular references\n            $scope.$watch('params', function(newParams, oldParams){\n                if (newParams === oldParams || !newParams) {\n                    return;\n                }\n\n                newParams.reload();\n            }, false);\n\n            $scope.$watch('params.isDataReloadRequired()', onDataReloadStatusChange);\n\n            this.compileDirectiveTemplates = function () {\n                if (!$element.hasClass('ng-table')) {\n                    $scope.templates = {\n                        header: ($attrs.templateHeader ? $attrs.templateHeader : 'ng-table/header.html'),\n                        pagination: ($attrs.templatePagination ? $attrs.templatePagination : 'ng-table/pager.html')\n                    };\n                    $element.addClass('ng-table');\n                    var headerTemplate = null;\n\n                    // $element.find('> thead').length === 0 doesn't work on jqlite\n                    var theadFound = false;\n                    angular.forEach($element.children(), function(e) {\n                        if (e.tagName === 'THEAD') {\n                            theadFound = true;\n                        }\n                    });\n                    if (!theadFound) {\n                        headerTemplate = angular.element(document.createElement('thead')).attr('ng-include', 'templates.header');\n                        $element.prepend(headerTemplate);\n                    }\n                    var paginationTemplate = angular.element(document.createElement('div')).attr({\n                        'ng-table-pagination': 'params',\n                        'template-url': 'templates.pagination'\n                    });\n                    $element.after(paginationTemplate);\n                    if (headerTemplate) {\n                        $compile(headerTemplate)($scope);\n                    }\n                    $compile(paginationTemplate)($scope);\n                }\n            };\n\n            this.loadFilterData = function ($columns) {\n                angular.forEach($columns, function ($column) {\n                    var result;\n                    result = $column.filterData($scope);\n                    if (!result) {\n                        delete $column.filterData;\n                        return;\n                    }\n\n                    // if we're working with a deferred object or a promise, let's wait for the promise\n                    /* WARNING: support for returning a $defer is depreciated */\n                    if ((angular.isObject(result) && (angular.isObject(result.promise) || angular.isFunction(result.then)))) {\n                        var pData = angular.isFunction(result.then) ? result : result.promise;\n                        delete $column.filterData;\n                        return pData.then(function(data) {\n                            // our deferred can eventually return arrays, functions and objects\n                            if (!angular.isArray(data) && !angular.isFunction(data) && !angular.isObject(data)) {\n                                // if none of the above was found - we just want an empty array\n                                data = [];\n                            }\n                            $column.data = data;\n                        });\n                    }\n                    // otherwise, we just return what the user gave us. It could be a function, array, object, whatever\n                    else {\n                        return $column.data = result;\n                    }\n                });\n            };\n\n            this.buildColumns = function (columns) {\n                var result = [];\n                (columns || []).forEach(function(col){\n                    result.push(ngTableColumn.buildColumn(col, $scope, result));\n                });\n                return result\n            };\n\n            this.parseNgTableDynamicExpr = function (attr) {\n                if (!attr || attr.indexOf(\" with \") > -1) {\n                    var parts = attr.split(/\\s+with\\s+/);\n                    return {\n                        tableParams: parts[0],\n                        columns: parts[1]\n                    };\n                } else {\n                    throw new Error('Parse error (expected example: ng-table-dynamic=\\'tableParams with cols\\')');\n                }\n            };\n\n            this.setupBindingsToInternalScope = function(tableParamsExpr){\n\n                // note: this we're setting up watches to simulate angular's isolated scope bindings\n\n                // note: is REALLY important to watch for a change to the ngTableParams *reference* rather than\n                // $watch for value equivalence. This is because ngTableParams references the current page of data as\n                // a field and it's important not to watch this\n                var tableParamsGetter = $parse(tableParamsExpr);\n                $scope.$watch(tableParamsGetter, (function (params) {\n                    if (angular.isUndefined(params)) {\n                        return;\n                    }\n                    $scope.paramsModel = tableParamsGetter;\n                    $scope.params = params;\n                }), false);\n\n                setupFilterRowBindingsToInternalScope();\n                setupGroupRowBindingsToInternalScope();\n            };\n\n            function setupFilterRowBindingsToInternalScope(){\n                if ($attrs.showFilter) {\n                    $scope.$parent.$watch($attrs.showFilter, function(value) {\n                        $scope.show_filter = value;\n                    });\n                } else {\n                    $scope.$watch(hasVisibleFilterColumn, function(value){\n                        $scope.show_filter = value;\n                    })\n                }\n\n                if ($attrs.disableFilter) {\n                    $scope.$parent.$watch($attrs.disableFilter, function(value) {\n                        $scope.$filterRow.disabled = value;\n                    });\n                }\n            }\n\n            function setupGroupRowBindingsToInternalScope(){\n                $scope.$groupRow = {};\n                if ($attrs.showGroup) {\n                    var showGroupGetter = $parse($attrs.showGroup);\n                    $scope.$parent.$watch(showGroupGetter, function(value) {\n                        $scope.$groupRow.show = value;\n                    });\n                    if (showGroupGetter.assign){\n                        // setup two-way databinding thus allowing ngTableGrowRow to assign to the showGroup expression\n                        $scope.$watch('$groupRow.show', function(value) {\n                            showGroupGetter.assign($scope.$parent, value);\n                        });\n                    }\n                } else{\n                    $scope.$watch('params.hasGroup()', function(newValue) {\n                        $scope.$groupRow.show = newValue;\n                    });\n                }\n            }\n\n            function getVisibleColumns(){\n                return ($scope.$columns || []).filter(function(c){\n                    return c.show($scope);\n                });\n            }\n\n            function hasVisibleFilterColumn(){\n                if (!$scope.$columns) return false;\n\n                return some($scope.$columns, function($column){\n                    return $column.show($scope) && $column.filter($scope);\n                });\n            }\n\n            function some(array, predicate){\n                var found = false;\n                for (var i = 0; i < array.length; i++) {\n                    var obj = array[i];\n                    if (predicate(obj)){\n                        found = true;\n                        break;\n                    }\n                }\n                return found;\n            }\n\n            function commonInit(){\n                ngTableEventsChannel.onAfterReloadData(bindDataToScope, $scope, isMyPublisher);\n                ngTableEventsChannel.onPagesChanged(bindPagesToScope, $scope, isMyPublisher);\n\n                function bindDataToScope(params, newDatapage){\n                    var visibleColumns = getVisibleColumns();\n                    if (params.hasGroup()) {\n                        $scope.$groups = newDatapage || [];\n                        $scope.$groups.visibleColumnCount = visibleColumns.length;\n                    } else {\n                        $scope.$data = newDatapage || [];\n                        $scope.$data.visibleColumnCount = visibleColumns.length;\n                    }\n                }\n\n                function bindPagesToScope(params, newPages){\n                    $scope.pages = newPages\n                }\n\n                function isMyPublisher(publisher){\n                    return $scope.params === publisher;\n                }\n            }\n\n            commonInit();\n        }]);\n})();\n\n/**\n * ngTable: Table + Angular JS\n *\n * @author Vitalii Savchuk <esvit666@gmail.com>\n * @url https://github.com/esvit/ng-table/\n * @license New BSD License <http://creativecommons.org/licenses/BSD/>\n */\n\n(function(){\n    /**\n     * @ngdoc directive\n     * @name ngTable\n     * @module ngTable\n     * @restrict A\n     *\n     * @description\n     * Directive that instantiates {@link ngTableController ngTableController}.\n     */\n    angular.module('ngTable').directive('ngTable', ['$q', '$parse',\n        function($q, $parse) {\n            'use strict';\n\n            return {\n                restrict: 'A',\n                priority: 1001,\n                scope: true,\n                controller: 'ngTableController',\n                compile: function(element) {\n                    var columns = [],\n                        i = 0,\n                        dataRow,\n                        groupRow,\n                        rows = [];\n\n                    angular.forEach(element.find('tr'), function(tr) {\n                        rows.push(angular.element(tr))\n                    });\n                    dataRow = rows.filter(function(tr){\n                        return !tr.hasClass('ng-table-group');\n                    })[0];\n                    groupRow = rows.filter(function(tr){\n                        return tr.hasClass('ng-table-group');\n                    })[0];\n\n                    if (!dataRow) {\n                        return;\n                    }\n                    angular.forEach(dataRow.find('td'), function(item) {\n                        var el = angular.element(item);\n                        if (el.attr('ignore-cell') && 'true' === el.attr('ignore-cell')) {\n                            return;\n                        }\n\n                        var getAttrValue = function(attr){\n                            return el.attr('x-data-' + attr) || el.attr('data-' + attr) || el.attr(attr);\n                        };\n                        var setAttrValue = function(attr, value){\n                            if (el.attr('x-data-' + attr)){\n                                el.attr('x-data-' + attr, value)\n                            } else if (el.attr('data' + attr)){\n                                el.attr('data' + attr, value)\n                            } else {\n                                el.attr(attr, value)\n                            }\n                        };\n\n                        var parsedAttribute = function(attr) {\n                            var expr = getAttrValue(attr);\n                            if (!expr){\n                                return undefined;\n                            }\n\n                            var localValue;\n                            var getter = function (context) {\n                                if (localValue !== undefined){\n                                    return localValue;\n                                }\n                                return $parse(expr)(context);\n                            };\n                            getter.assign = function($scope, value){\n                                var parsedExpr = $parse(expr);\n                                if (parsedExpr.assign) {\n                                    // we should be writing back to the parent scope as this is where the expression\n                                    // came from\n                                    parsedExpr.assign($scope.$parent, value);\n                                } else {\n                                    localValue = value;\n                                }\n                            };\n                            return getter;\n                        };\n                        var titleExpr = getAttrValue('title-alt') || getAttrValue('title');\n                        if (titleExpr){\n                            el.attr('data-title-text', '{{' + titleExpr + '}}'); // this used in responsive table\n                        }\n                        // NOTE TO MAINTAINERS: if you add extra fields to a $column be sure to extend ngTableColumn with\n                        // a corresponding \"safe\" default\n                        columns.push({\n                            id: i++,\n                            title: parsedAttribute('title'),\n                            titleAlt: parsedAttribute('title-alt'),\n                            headerTitle: parsedAttribute('header-title'),\n                            sortable: parsedAttribute('sortable'),\n                            'class': parsedAttribute('header-class'),\n                            filter: parsedAttribute('filter'),\n                            groupable: parsedAttribute('groupable'),\n                            headerTemplateURL: parsedAttribute('header'),\n                            filterData: parsedAttribute('filter-data'),\n                            show: el.attr(\"ng-if\") ? parsedAttribute('ng-if') : undefined\n                        });\n\n                        if (groupRow || el.attr(\"ng-if\")){\n                            // change ng-if to bind to our column definition which we know will be writable\n                            // because this will potentially increase the $watch count, only do so if we already have an\n                            // ng-if or when we definitely need to change visibility of the columns.\n                            // currently only ngTableGroupRow directive needs to change visibility\n                            setAttrValue('ng-if', '$columns[' + (columns.length - 1) + '].show(this)');\n                        }\n                    });\n                    return function(scope, element, attrs, controller) {\n                        scope.$columns = columns = controller.buildColumns(columns);\n\n                        controller.setupBindingsToInternalScope(attrs.ngTable);\n                        controller.loadFilterData(columns);\n                        controller.compileDirectiveTemplates();\n                    };\n                }\n            }\n        }\n    ]);\n})();\n\n/**\n * ngTable: Table + Angular JS\n *\n * @author Vitalii Savchuk <esvit666@gmail.com>\n * @url https://github.com/esvit/ng-table/\n * @license New BSD License <http://creativecommons.org/licenses/BSD/>\n */\n\n(function(){\n\n    /**\n     * @ngdoc directive\n     * @name ngTableDynamic\n     * @module ngTable\n     * @restrict A\n     *\n     * @description\n     * A dynamic version of the {@link ngTable ngTable} directive that accepts a dynamic list of columns\n     * definitions to render\n     */\n    angular.module('ngTable').directive('ngTableDynamic', [function (){\n\n        return {\n            restrict: 'A',\n            priority: 1001,\n            scope: true,\n            controller: 'ngTableController',\n            compile: function(tElement) {\n                var row;\n\n                // IE 8 fix :not(.ng-table-group) selector\n                angular.forEach(tElement.find('tr'), function(tr) {\n                    tr = angular.element(tr);\n                    if (!tr.hasClass('ng-table-group') && !row) {\n                        row = tr;\n                    }\n                });\n                if (!row) {\n                    return;\n                }\n\n                angular.forEach(row.find('td'), function(item) {\n                    var el = angular.element(item);\n                    var getAttrValue = function(attr){\n                        return el.attr('x-data-' + attr) || el.attr('data-' + attr) || el.attr(attr);\n                    };\n\n                    // this used in responsive table\n                    var titleExpr = getAttrValue('title');\n                    if (!titleExpr){\n                        el.attr('data-title-text', '{{$columns[$index].titleAlt(this) || $columns[$index].title(this)}}');\n                    }\n                    var showExpr = el.attr('ng-if');\n                    if (!showExpr){\n                        el.attr('ng-if', '$columns[$index].show(this)');\n                    }\n                });\n                return function (scope, element, attrs, controller) {\n                    var expr = controller.parseNgTableDynamicExpr(attrs.ngTableDynamic);\n\n                    controller.setupBindingsToInternalScope(expr.tableParams);\n                    controller.compileDirectiveTemplates();\n\n                    scope.$watchCollection(expr.columns, function (newCols/*, oldCols*/) {\n                        scope.$columns = controller.buildColumns(newCols);\n                        controller.loadFilterData(scope.$columns);\n                    });\n                };\n            }\n        };\n    }]);\n})();\n\n/**\n * ngTable: Table + Angular JS\n *\n * @author Vitalii Savchuk <esvit666@gmail.com>\n * @url https://github.com/esvit/ng-table/\n * @license New BSD License <http://creativecommons.org/licenses/BSD/>\n */\n\n(function(){\n    'use strict';\n\n    angular.module('ngTable')\n        .directive('ngTableColumnsBinding', ngTableColumnsBinding);\n\n    ngTableColumnsBinding.$inject = [\"$parse\"];\n\n    /**\n     * @ngdoc directive\n     * @name ngTableColumnsBinding\n     * @description One-way data binds the $columns array generated by ngTable/ngTableDynamic to the specified\n     * expression.\n     *\n     * This allows the $columns array to be accessed outside of the html table markup\n     */\n    function ngTableColumnsBinding($parse){\n        var directive = {\n            restrict: 'A',\n            require: 'ngTable',\n            link: linkFn\n        };\n        return directive;\n\n        function linkFn($scope, $element, $attrs){\n            var setter = $parse($attrs.ngTableColumnsBinding).assign;\n            if (setter){\n                $scope.$watch('$columns', function(newColumns){\n                    var shallowClone = (newColumns || []).slice(0);\n                    setter($scope, shallowClone);\n                });\n            }\n        }\n    }\n})();\n\n/**\n * ngTable: Table + Angular JS\n *\n * @author Vitalii Savchuk <esvit666@gmail.com>\n * @url https://github.com/esvit/ng-table/\n * @license New BSD License <http://creativecommons.org/licenses/BSD/>\n */\n\n(function(){\n    /**\n     * @ngdoc directive\n     * @name ngTablePagination\n     * @module ngTable\n     * @restrict A\n     */\n    angular.module('ngTable').directive('ngTablePagination', ['$compile', 'ngTableEventsChannel',\n        function($compile, ngTableEventsChannel) {\n            'use strict';\n\n            return {\n                restrict: 'A',\n                scope: {\n                    'params': '=ngTablePagination',\n                    'templateUrl': '='\n                },\n                replace: false,\n                link: function(scope, element/*, attrs*/) {\n\n                    ngTableEventsChannel.onAfterReloadData(function(pubParams) {\n                        scope.pages = pubParams.generatePagesArray();\n                    }, scope, function(pubParams){\n                        return pubParams === scope.params;\n                    });\n\n                    scope.$watch('templateUrl', function(templateUrl) {\n                        if (angular.isUndefined(templateUrl)) {\n                            return;\n                        }\n                        var template = angular.element(document.createElement('div'));\n                        template.attr({\n                            'ng-include': 'templateUrl'\n                        });\n                        element.append(template);\n                        $compile(template)(scope);\n                    });\n                }\n            };\n        }\n    ]);\n\n})();\n\n/**\n * ngTable: Table + Angular JS\n *\n * @author Vitalii Savchuk <esvit666@gmail.com>\n * @url https://github.com/esvit/ng-table/\n * @license New BSD License <http://creativecommons.org/licenses/BSD/>\n */\n\n(function(){\n    'use strict';\n\n    angular.module('ngTable')\n        .controller('ngTableFilterRowController', ngTableFilterRowController);\n\n    ngTableFilterRowController.$inject = ['$scope', 'ngTableFilterConfig'];\n\n    function ngTableFilterRowController($scope, ngTableFilterConfig){\n\n        $scope.config = ngTableFilterConfig;\n\n        $scope.getFilterCellCss = function (filter, layout){\n            if (layout !== 'horizontal') {\n                return 's12';\n            }\n\n            var size = Object.keys(filter).length;\n            var width = parseInt(12 / size, 10);\n            return 's' + width;\n        };\n\n        $scope.getFilterPlaceholderValue = function(filterValue/*, filterName*/){\n            if (angular.isObject(filterValue)) {\n                return filterValue.placeholder;\n            } else {\n                return '';\n            }\n        };\n    }\n})();\n\n/**\n * ngTable: Table + Angular JS\n *\n * @author Vitalii Savchuk <esvit666@gmail.com>\n * @url https://github.com/esvit/ng-table/\n * @license New BSD License <http://creativecommons.org/licenses/BSD/>\n */\n\n(function(){\n    'use strict';\n\n    angular.module('ngTable')\n        .directive('ngTableFilterRow', ngTableFilterRow);\n\n    ngTableFilterRow.$inject = [];\n\n    function ngTableFilterRow(){\n        var directive = {\n            restrict: 'E',\n            replace: true,\n            templateUrl: 'ng-table/filterRow.html',\n            scope: true,\n            controller: 'ngTableFilterRowController'\n        };\n        return directive;\n    }\n})();\n\n/**\n * ngTable: Table + Angular JS\n *\n * @author Vitalii Savchuk <esvit666@gmail.com>\n * @url https://github.com/esvit/ng-table/\n * @license New BSD License <http://creativecommons.org/licenses/BSD/>\n */\n\n(function(){\n    'use strict';\n\n    angular.module('ngTable')\n        .controller('ngTableGroupRowController', ngTableGroupRowController);\n\n    ngTableGroupRowController.$inject = ['$scope'];\n\n    function ngTableGroupRowController($scope){\n\n        var groupFns = [];\n\n        init();\n\n        function init(){\n            $scope.getGroupables = getGroupables;\n            $scope.getGroupTitle = getGroupTitle;\n            $scope.getVisibleColumns = getVisibleColumns;\n            $scope.groupBy = groupBy;\n            $scope.isSelectedGroup = isSelectedGroup;\n            $scope.toggleDetail = toggleDetail;\n\n            $scope.$watch('params.group()', setGroup, true);\n        }\n\n        function changeSortDirection(){\n            var newDirection;\n            if ($scope.params.hasGroup($scope.$selGroup, 'asc')) {\n                newDirection = 'desc';\n            } else if ($scope.params.hasGroup($scope.$selGroup, 'desc')){\n                newDirection = '';\n            } else {\n                newDirection = 'asc';\n            }\n            $scope.params.group($scope.$selGroup, newDirection);\n        }\n\n        function findGroupColumn(groupKey) {\n            return $scope.$columns.filter(function ($column) {\n                return $column.groupable($scope) === groupKey;\n            })[0];\n        }\n\n        function getGroupTitle(group){\n            return angular.isFunction(group) ? group.title : group.title($scope);\n        }\n\n        function getGroupables(){\n            var groupableCols = $scope.$columns.filter(function ($column) {\n                return $column.groupable($scope);\n            });\n            return groupFns.concat(groupableCols);\n        }\n\n        function getVisibleColumns(){\n            return $scope.$columns.filter(function($column){\n                return $column.show($scope);\n            })\n        }\n\n        function groupBy(group){\n            if (isSelectedGroup(group)){\n                changeSortDirection();\n            } else {\n                if (group.groupable){\n                    $scope.params.group(group.groupable($scope));\n                } else{\n                    $scope.params.group(group);\n                }\n            }\n        }\n\n        function isSelectedGroup(group){\n            if (group.groupable){\n                return group.groupable($scope) === $scope.$selGroup;\n            } else {\n                return group === $scope.$selGroup;\n            }\n        }\n\n        function setGroup(group){\n            var existingGroupCol = findGroupColumn($scope.$selGroup);\n            if (existingGroupCol && existingGroupCol.show.assign){\n                existingGroupCol.show.assign($scope, true);\n            }\n            if (angular.isFunction(group)) {\n                groupFns = [group];\n                $scope.$selGroup = group;\n                $scope.$selGroupTitle = group.title;\n            } else {\n                // note: currently only one group is implemented\n                var groupKey = Object.keys(group || {})[0];\n                var groupedColumn = findGroupColumn(groupKey);\n                if (groupedColumn) {\n                    $scope.$selGroupTitle = groupedColumn.title($scope);\n                    $scope.$selGroup = groupKey;\n                    if (groupedColumn.show.assign) {\n                        groupedColumn.show.assign($scope, false);\n                    }\n                }\n            }\n        }\n\n        function toggleDetail(){\n            $scope.params.settings().groupOptions.isExpanded = !$scope.params.settings().groupOptions.isExpanded;\n            return $scope.params.reload();\n        }\n    }\n})();\n\n/**\n * ngTable: Table + Angular JS\n *\n * @author Vitalii Savchuk <esvit666@gmail.com>\n * @url https://github.com/esvit/ng-table/\n * @license New BSD License <http://creativecommons.org/licenses/BSD/>\n */\n\n(function(){\n    'use strict';\n\n    angular.module('ngTable')\n        .directive('ngTableGroupRow', ngTableGroupRow);\n\n    ngTableGroupRow.$inject = [];\n\n    function ngTableGroupRow(){\n        var directive = {\n            restrict: 'E',\n            replace: true,\n            templateUrl: 'ng-table/groupRow.html',\n            scope: true,\n            controller: 'ngTableGroupRowController',\n            controllerAs: 'dctrl'\n        };\n        return directive;\n    }\n})();\n\n/**\n * ngTable: Table + Angular JS\n *\n * @author Vitalii Savchuk <esvit666@gmail.com>\n * @url https://github.com/esvit/ng-table/\n * @license New BSD License <http://creativecommons.org/licenses/BSD/>\n */\n\n(function(){\n    'use strict';\n\n    angular.module('ngTable')\n        .controller('ngTableSorterRowController', ngTableSorterRowController);\n\n    ngTableSorterRowController.$inject = ['$scope'];\n\n    function ngTableSorterRowController($scope){\n\n        $scope.sortBy = sortBy;\n\n        ///////////\n\n        function sortBy($column, event) {\n            var parsedSortable = $column.sortable && $column.sortable();\n            if (!parsedSortable) {\n                return;\n            }\n            var defaultSort = $scope.params.settings().defaultSort;\n            var inverseSort = (defaultSort === 'asc' ? 'desc' : 'asc');\n            var sorting = $scope.params.sorting() && $scope.params.sorting()[parsedSortable] && ($scope.params.sorting()[parsedSortable] === defaultSort);\n            var sortingParams = (event.ctrlKey || event.metaKey) ? $scope.params.sorting() : {};\n            sortingParams[parsedSortable] = (sorting ? inverseSort : defaultSort);\n            $scope.params.parameters({\n                sorting: sortingParams\n            });\n        }\n    }\n})();\n\n/**\n * ngTable: Table + Angular JS\n *\n * @author Vitalii Savchuk <esvit666@gmail.com>\n * @url https://github.com/esvit/ng-table/\n * @license New BSD License <http://creativecommons.org/licenses/BSD/>\n */\n\n(function(){\n    'use strict';\n\n    angular.module('ngTable')\n        .directive('ngTableSorterRow', ngTableSorterRow);\n\n    ngTableSorterRow.$inject = [];\n\n    function ngTableSorterRow(){\n        var directive = {\n            restrict: 'E',\n            replace: true,\n            templateUrl: 'ng-table/sorterRow.html',\n            scope: true,\n            controller: 'ngTableSorterRowController'\n        };\n        return directive;\n    }\n})();\n\n/**\n * ngTable: Table + Angular JS\n *\n * @author Vitalii Savchuk <esvit666@gmail.com>\n * @url https://github.com/esvit/ng-table/\n * @license New BSD License <http://creativecommons.org/licenses/BSD/>\n */\n\n(function(){\n    'use strict';\n\n    /**\n     * @ngdoc directive\n     * @name ngTableSelectFilterDs\n     * @module ngTable\n     * @restrict A\n     *\n     * @description\n     * Takes the array returned by $column.filterData and makes it available as `$selectData` on the `$scope`.\n     *\n     * The resulting `$selectData` array will contain an extra item that is suitable to represent the user\n     * \"deselecting\" an item from a `<select>` tag\n     *\n     * This directive is is focused on providing a datasource to an `ngOptions` directive\n     */\n    angular.module('ngTable')\n        .directive('ngTableSelectFilterDs', ngTableSelectFilterDs);\n\n    ngTableSelectFilterDs.$inject = [];\n\n    function ngTableSelectFilterDs(){\n        // note: not using isolated or child scope \"by design\"\n        // this is to allow this directive to be combined with other directives that do\n\n        var directive = {\n            restrict: 'A',\n            controller: ngTableSelectFilterDsController\n        };\n        return directive;\n    }\n\n    ngTableSelectFilterDsController.$inject = ['$scope', '$parse', '$attrs', '$q'];\n    function ngTableSelectFilterDsController($scope, $parse, $attrs, $q){\n\n        var $column = {};\n        init();\n\n        function init(){\n            $column = $parse($attrs.ngTableSelectFilterDs)($scope);\n            $scope.$watch(function(){\n                return $column.data;\n            }, bindDataSource);\n        }\n\n        function bindDataSource(){\n            getSelectListData($column).then(function(data){\n                if (data && !hasEmptyOption(data)){\n                    data.unshift({ id: '', title: ''});\n                }\n                data = data || [];\n                $scope.$selectData = data;\n            });\n        }\n\n        function hasEmptyOption(data) {\n            var isMatch;\n            for (var i = 0; i < data.length; i++) {\n                var item = data[i];\n                if (item && item.id === '') {\n                    isMatch = true;\n                    break;\n                }\n            }\n            return isMatch;\n        }\n\n        function getSelectListData($column) {\n            var data = angular.isFunction($column.data) ? $column.data() : $column.data;\n            return $q.when(data);\n        }\n    }\n})();\n\nangular.module('ngTable').run(['$templateCache', function ($templateCache) {\n\t$templateCache.put('ng-table/filterRow.html', '<tr ng-show=\"show_filter\" class=\"ng-table-filters\"> <th data-title-text=\"{{$column.titleAlt(this) || $column.title(this)}}\" ng-repeat=\"$column in $columns\" ng-if=\"$column.show(this)\" class=\"filter {{$column.class(this)}}\" ng-class=\"params.settings().filterOptions.filterLayout===\\'horizontal\\' ? \\'filter-horizontal\\' : \\'\\'\"> <div ng-repeat=\"(name, filter) in $column.filter(this)\" ng-include=\"config.getTemplateUrl(filter)\" class=\"filter-cell\" ng-class=\"[getFilterCellCss($column.filter(this), params.settings().filterOptions.filterLayout), $last ? \\'last\\' : \\'\\']\"> </div> </th> </tr> ');\n\t$templateCache.put('ng-table/filters/number.html', '<input type=\"number\" name=\"{{name}}\" ng-disabled=\"$filterRow.disabled\" ng-model=\"params.filter()[name]\" class=\"input-filter form-control\" placeholder=\"{{getFilterPlaceholderValue(filter, name)}}\"/> ');\n\t$templateCache.put('ng-table/filters/select-multiple.html', '<select ng-options=\"data.id as data.title for data in $column.data\" ng-disabled=\"$filterRow.disabled\" multiple ng-multiple=\"true\" ng-model=\"params.filter()[name]\" class=\"filter filter-select-multiple form-control\" name=\"{{name}}\"> </select> ');\n\t$templateCache.put('ng-table/filters/select.html', '<select ng-options=\"data.id as data.title for data in $selectData\" ng-table-select-filter-ds=\"$column\" ng-disabled=\"$filterRow.disabled\" ng-model=\"params.filter()[name]\" class=\"filter filter-select form-control\" name=\"{{name}}\"> <option style=\"display:none\" value=\"\"></option> </select> ');\n\t$templateCache.put('ng-table/filters/text.html', '<input type=\"text\" name=\"{{name}}\" ng-disabled=\"$filterRow.disabled\" ng-model=\"params.filter()[name]\" class=\"input-filter form-control\" placeholder=\"{{getFilterPlaceholderValue(filter, name)}}\"/> ');\n\t$templateCache.put('ng-table/groupRow.html', '<tr ng-if=\"params.hasGroup()\" ng-show=\"$groupRow.show\" class=\"ng-table-group-header\"> <th colspan=\"{{getVisibleColumns().length}}\" class=\"sortable\" ng-class=\"{ \\'sort-asc\\': params.hasGroup($selGroup, \\'asc\\'), \\'sort-desc\\':params.hasGroup($selGroup, \\'desc\\') }\"> <a href=\"\" ng-click=\"isSelectorOpen=!isSelectorOpen\" class=\"ng-table-group-selector\"> <strong class=\"sort-indicator\">{{$selGroupTitle}}</strong> <button class=\"btn btn-default btn-xs ng-table-group-close\" ng-click=\"$groupRow.show=false; $event.preventDefault(); $event.stopPropagation();\"> <span class=\"glyphicon glyphicon-remove\"></span> </button> <button class=\"btn btn-default btn-xs ng-table-group-toggle\" ng-click=\"toggleDetail(); $event.preventDefault(); $event.stopPropagation();\"> <span class=\"glyphicon\" ng-class=\"{ \\'glyphicon-resize-small\\': params.settings().groupOptions.isExpanded, \\'glyphicon-resize-full\\': !params.settings().groupOptions.isExpanded }\"></span> </button> </a> <div class=\"list-group\" ng-if=\"isSelectorOpen\"> <a href=\"\" class=\"list-group-item\" ng-repeat=\"group in getGroupables()\" ng-click=\"groupBy(group)\"> <strong>{{ getGroupTitle(group)}}</strong> <strong ng-class=\"isSelectedGroup(group) && \\'sort-indicator\\'\"></strong> </a> </div> </th> </tr> ');\n\t$templateCache.put('ng-table/header.html', '<ng-table-group-row></ng-table-group-row> <ng-table-sorter-row></ng-table-sorter-row> <ng-table-filter-row></ng-table-filter-row> ');\n\t$templateCache.put('ng-table/pager.html', '<div class=\"ng-cloak ng-table-pager\" ng-if=\"params.data.length\"> <div ng-if=\"params.settings().counts.length\" class=\"ng-table-counts btn-group pull-right\"> <button ng-repeat=\"count in params.settings().counts\" type=\"button\" ng-class=\"{\\'active\\':params.count()==count}\" ng-click=\"params.count(count)\" class=\"btn btn-default\"> <span ng-bind=\"count\"></span> </button> </div> <ul ng-if=\"pages.length\" class=\"pagination ng-table-pagination\"> <li ng-class=\"{\\'disabled\\': !page.active && !page.current, \\'active\\': page.current}\" ng-repeat=\"page in pages\" ng-switch=\"page.type\"> <a ng-switch-when=\"prev\" ng-click=\"params.page(page.number)\" href=\"\">&laquo;</a> <a ng-switch-when=\"first\" ng-click=\"params.page(page.number)\" href=\"\"><span ng-bind=\"page.number\"></span></a> <a ng-switch-when=\"page\" ng-click=\"params.page(page.number)\" href=\"\"><span ng-bind=\"page.number\"></span></a> <a ng-switch-when=\"more\" ng-click=\"params.page(page.number)\" href=\"\">&#8230;</a> <a ng-switch-when=\"last\" ng-click=\"params.page(page.number)\" href=\"\"><span ng-bind=\"page.number\"></span></a> <a ng-switch-when=\"next\" ng-click=\"params.page(page.number)\" href=\"\">&raquo;</a> </li> </ul> </div> ');\n\t$templateCache.put('ng-table/sorterRow.html', '<tr class=\"ng-table-sort-header\"> <th title=\"{{$column.headerTitle(this)}}\" ng-repeat=\"$column in $columns\" ng-class=\"{ \\'sortable\\': $column.sortable(this), \\'sort-asc\\': params.sorting()[$column.sortable(this)]==\\'asc\\', \\'sort-desc\\': params.sorting()[$column.sortable(this)]==\\'desc\\' }\" ng-click=\"sortBy($column, $event)\" ng-if=\"$column.show(this)\" ng-init=\"template=$column.headerTemplateURL(this)\" class=\"header {{$column.class(this)}}\"> <div ng-if=\"!template\" class=\"ng-table-header\" ng-class=\"{\\'sort-indicator\\': params.settings().sortingIndicator==\\'div\\'}\"> <span ng-bind=\"$column.title(this)\" ng-class=\"{\\'sort-indicator\\': params.settings().sortingIndicator==\\'span\\'}\"></span> </div> <div ng-if=\"template\" ng-include=\"template\"></div> </th> </tr> ');\n}]);\n    return angular.module('ngTable');\n}));\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/ffan-ng-table/dist/ng-table.js\n// module id = 397\n// module chunks = 4"],"sourceRoot":""}